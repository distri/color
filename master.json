{
  "source": {
    "LICENSE": {
      "path": "LICENSE",
      "mode": "100644",
      "content": "The MIT License (MIT)\n\nCopyright (c) 2013 distri\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
      "type": "blob"
    },
    "README.md": {
      "path": "README.md",
      "mode": "100644",
      "content": "color\n=====\n\nTaste the rainbow\n",
      "type": "blob"
    },
    "main.coffee.md": {
      "path": "main.coffee.md",
      "mode": "100644",
      "content": "Color\n=====\n\n    rgbParser = /^rgba?\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3}),?\\s*(\\d?\\.?\\d*)?\\)$/\n    hslParser = /^hsla?\\((\\d{1,3}),\\s*(\\d?\\.?\\d*),\\s*(\\d?\\.?\\d*),?\\s*(\\d?\\.?\\d*)?\\)$/\n    \n    {round} = Math\n    \n    parseHex = (str) ->\n      hexString = str.replace(/#/, '')\n\n      switch hexString.length\n        when 3, 4\n          if hexString.length == 4\n            alpha = ((parseInt(hexString.substr(3, 1), 16) * 0x11) / 255)\n          else\n            alpha = 1\n    \n          rgb = (parseInt(hexString.substr(i, 1), 16) * 0x11 for i in [0..2])      \n          rgb.push(alpha)    \n    \n          return rgb\n    \n        when 6, 8\n          if hexString.length == 8\n            alpha = (parseInt(hexString.substr(6, 2), 16) / 255)\n          else\n            alpha = 1\n    \n          rgb = (parseInt(hexString.substr(2 * i, 2), 16) for i in [0..2])          \n          rgb.push(alpha)\n    \n          return rgb\n\n      return\n\n    parseRGB = (colorString) ->\n      return undefined unless channels = rgbParser.exec(colorString)\n    \n      parsedColor = (parseFloat channel for channel in channels[1..4])\n    \n      parsedColor[3] = 1 if isNaN(parsedColor[3])\n    \n      return parsedColor\n    \n    parseHSL = (colorString) ->\n      return undefined unless channels = hslParser.exec(colorString)\n    \n      parsedColor = (parseFloat channel for channel in channels[1..4])\n    \n      parsedColor[3] = 1 if isNaN(parsedColor[3])\n    \n      return hslToRgb(parsedColor)\n    \n    hsvToRgb = (hsv) ->\n      r = g = b = null\n    \n      [h, s, v, a] = hsv\n    \n      a = 1 unless a?\n    \n      i = (h / 60).floor()\n      f = h / 60 - i\n      p = v * (1 - s)\n      q = v * (1 - f * s)\n      t = v * (1 - (1 - f) * s)\n    \n      switch (i % 6)\n        when 0\n          r = v\n          g = t\n          b = p\n        when 1\n          r = q\n          g = v\n          b = p\n        when 2\n          r = p\n          g = v\n          b = t\n        when 3\n          r = p\n          g = q\n          b = v\n        when 4\n          r = t\n          g = p\n          b = v\n        when 5\n          r = v\n          g = p\n          b = q\n    \n      rgb = [round(r * 255), round(g * 255), round(b * 255)]\n    \n      return rgb.concat(a)\n    \n    hslToRgb = (hsl) ->    \n      [h, s, l, a] = hsl\n    \n      h = h % 360\n      a = 1 unless a?\n    \n      r = g = b = null\n    \n      hueToRgb = (p, q, hue) ->\n        hue = hue.mod(360)      \n    \n        return p + (q - p) * (hue / 60) if hue < 60\n        return q if hue < 180\n        return p + (q - p) * ((240 - hue) / 60) if hue < 240\n        return p\n    \n      if s == 0\n        r = g = b = l\n      else\n        q = (if l < 0.5 then l * (1 + s) else l + s - l * s)\n        p = 2 * l - q\n        r = hueToRgb(p, q, h + 120)\n        g = hueToRgb(p, q, h)\n        b = hueToRgb(p, q, h - 120)\n    \n      rgbMap = (round(channel * 255) for channel in [r, g, b])\n    \n      return rgbMap.concat(a)\n      \n    channelize = (color, alpha) ->\n      return color.channels() if color.channels?\n      if Array.isArray color\n        if alpha?\n          alpha = parseFloat(alpha)\n        else if color[3]?\n          alpha = parseFloat(color[3])\n        else\n          alpha = 1\n    \n        result = (parseFloat(channel) for channel in color[0..2]).concat(alpha)\n      else\n        result = Color.lookup?(color) || parseHex(color) || parseRGB(color) || parseHSL(color)\n    \n        if alpha?\n          result[3] = parseFloat(alpha)\n    \n      return result\n    \n    ###*\n    Create a new color. The constructor is very flexible. It accepts individual r, g, b, a values,\n    arrays of r, g, b values, hex strings, rgb strings, hsl strings, other Color objects, \n    and even the named colors from the xkcd survey: http://blog.xkcd.com/2010/05/03/color-survey-results/. \n    If no arguments are given, defaults to transparent.\n    \n        individualRgb = Color(23, 56, 49, 0.4)\n      \n        arrayRgb = Color([59, 100, 230])\n      \n        hex = Color('#ff0000')\n      \n        rgb = Color('rgb(0, 255, 0)')\n      \n        hsl = Color('hsl(180, 1, 0.5)')\n      \n        anotherColor = Color('blue')\n      \n        Color(anotherColor)\n        # => a new color with the same r, g, b, and alpha values as `anotherColor`\n      \n        # You have access to all sorts of weird colors.\n        # We give you all the named colors the browser recognizes\n        # and the ones from this survey \n        # http://blog.xkcd.com/2010/05/03/color-survey-results/\n        namedBrown = Color('Fuzzy Wuzzy Brown')\n      \n        # Uutput color in Hex format \n        namedBrown.toHex()\n        # => '#c45655'\n      \n        # Default behavior\n        transparent = Color()\n      \n        transparent.toString()\n        # => 'rgba(0, 0, 0, 0)' \n      \n        # let's print out the colors on a canvas to see what they look like\n        canvas.font('14px Helvetica')\n        for color, index in ['individualRgb', 'arrayRgb', 'hex', 'rgb', 'hsl', 'anotherColor', 'namedBrown']\n          canvas.centerText\n            color: eval(color)\n            text: color\n            y: 20 * (index + 1)  \n    \n    @name Color\n    @param {Array|Number|String|Color} args... An Array, r, g, b values, \n    a sequence of numbers defining r, g, b values, a hex or hsl string, another Color object, or a named color\n    @constructor\n    ###\n    Color = (args...) ->\n      parsedColor = \n        switch args.length\n          when 0\n            [0, 0, 0, 0]\n          when 1\n            [first] = args\n            channelize(first)\n          when 2\n            [first, last] = args\n            channelize(first, last)\n          else     \n            channelize(args)\n    \n      throw \"#{args.join(',')} is an unknown color\" unless parsedColor   \n    \n      __proto__: Color::\n      r: round parsedColor[0]\n      g: round parsedColor[1]\n      b: round parsedColor[2]\n      a: parsedColor[3] \n    \n    Color:: =\n      ###*\n      Returns the rgba color channels in an array.\n    \n          transparent =  Color()\n      \n          transparent.channels()\n          # => [0, 0, 0, 0]\n      \n          red = Color(\"#FF0000\")\n      \n          red.channels()\n          # => [255, 0, 0, 1]\n      \n          rgb = Color(200, 34, 2)\n      \n          rgb.channels()\n          # => [200, 34, 2, 1]\n    \n      @name channels\n      @methodOf Color#\n    \n      @returns {Array} Array of r, g, b, and alpha values of the color\n      ###  \n      channels: ->\n        [@r, @g, @b, @a]\n    \n      ###*\n      A copy of the calling color that is its complementary color on the color wheel.\n    \n          red = Color(255, 0, 0)\n      \n          cyan = red.complement()\n      \n          # to see what they look like\n          for color, index in [red, cyan]\n            canvas.drawRect\n              color: color\n              x: 20 + (60 * index)\n              y: 20 + (60 * index)\n              width: 60\n              height: 60         \n    \n      @name complement\n      @methodOf Color#\n    \n      @returns {Color} new color that is a copy of the calling color with its hue shifted by 180 degrees on the color wheel\n      ### \n      complement: ->\n        @copy().complement$() \n    \n      ###*\n      Modifies the calling color to make it the complement of its previous value.\n    \n          red = Color(255, 0, 0)\n      \n          # modifies red in place to make it into cyan\n          red.complement$()\n      \n          red.toString()\n          # => 'rgba(0, 255, 255, 1)'\n    \n      @name complement$\n      @methodOf Color#\n    \n      @returns {Color} the color hue shifted by 180 degrees on the color wheel. Modifies the existing color.\n      ### \n      complement$: ->\n        @shiftHue$(180)\n    \n      ###*\n      A copy of the calling color.\n    \n          color = Color(0, 100, 200)\n      \n          copy = color.copy()\n      \n          color == copy\n          # => false\n      \n          color.equal(copy)\n          # => true\n    \n      @name copy\n      @methodOf Color#\n    \n      @returns {Color} A new color. A copy of the calling color\n      ### \n      copy: ->\n        Color(@r, @g, @b, @a)\n    \n      ###*\n      Returns a copy of the calling color darkened by `amount` (Lightness of the color ranges from 0 to 1).\n    \n          green = Color(0, 255, 0)\n      \n          darkGreen = green.darken(0.3)\n      \n          # to see what they look like\n          for color, index in [green, darkGreen]\n            canvas.drawRect\n              color: color\n              x: 20 + (60 * index)\n              y: 20 + (60 * index)\n              width: 60\n              height: 60         \n    \n      @name darken\n      @methodOf Color#\n      @param {Number} amount Amount to darken color by (between 0 - 1)\n    \n      @returns {Color} A new color. The lightness value is reduced by `amount` from the original.\n      ###\n      darken: (amount) ->\n        @copy().darken$(amount)\n    \n      ###*\n      Modifies the color so that it is darkened by `amount` (Lightness of the color ranges from 0 to 1).\n    \n          green = Color(0, 255, 0)\n      \n          # Modifies green to be darkGreen\n          green.darken$(0.3)\n      \n          green.toString()\n          # => 'rgba(0, 102, 0, 1)'\n    \n      @name darken$\n      @methodOf Color#\n      @param {Number} amount Amount to darken color by (between 0 - 1)\n    \n      @returns {Color} the color with the lightness value reduced by `amount`\n      ###\n      darken$: (amount) ->\n        hsl = @toHsl()\n        hsl[2] -= amount\n    \n        [@r, @g, @b, @a] = hslToRgb(hsl) \n    \n        return this      \n    \n      ###*\n      A copy of the calling color with its saturation reduced by `amount`.\n    \n          blue = Color(0, 0, 255)\n      \n          desaturatedBlue = blue.desaturate(0.4)\n      \n          # to see what they look like\n          for color, index in [blue, desaturatedBlue]\n            canvas.drawRect\n              color: color\n              x: 20 + (60 * index)\n              y: 20 + (60 * index)\n              width: 60\n              height: 60  \n    \n      @name desaturate\n      @methodOf Color#\n      @param {Number} amount Amount to reduce color saturation by (between 0 and 1)\n    \n      @returns {Color} A copy of the color with the saturation value reduced by `amount`\n      ###\n      desaturate: (amount) ->\n        @copy().desaturate$(amount) \n    \n      ###*\n      The modified color with its saturation reduced by `amount`.\n    \n          blue = Color(0, 0, 255)\n      \n          # modifies blue to be desaturatedBlue\n          blue.desaturate$(0.4)\n      \n          blue.toString()\n          # => 'rgba(38, 38, 217, 1)'\n    \n      @name desaturate$\n      @methodOf Color#\n      @param {Number} amount Amount to reduce color saturation by (between 0 and 1)\n    \n      @returns {Color} the color with the saturation value reduced by `amount`\n      ###\n      desaturate$: (amount) ->\n        hsl = @toHsl()\n        hsl[1] -= amount\n    \n        [@r, @g, @b, @a] = hslToRgb(hsl)\n    \n        return this    \n    \n      ###*\n      Determine whether two colors are equal. Compares their r, g, b, and alpha values.\n    \n          hex = Color('#ffff00')\n          rgb = Color(255, 255, 0)\n      \n          hex == rgb\n          # => false\n      \n          hex.equal(rgb)\n          # => true\n    \n      @name equal\n      @methodOf Color#\n      @param {Color} other the color to compare to the calling color\n    \n      @returns {Boolean} true if the r, g, b, a values of the colors agree, false otherwise\n      ###\n      equal: (other) ->\n        other.r == @r &&\n        other.g == @g &&\n        other.b == @b &&\n        other.a == @a\n    \n      ###*\n      A copy of the calling color converted to grayscale.\n      \n          yellow = Color(255, 255, 0)\n      \n          gray = yellow.grayscale()\n      \n          # to see what they look like\n          for color, index in [yellow, gray]\n            canvas.drawRect\n              color: color\n              x: 20 + (60 * index)\n              y: 20 + (60 * index)\n              width: 60\n              height: 60 \n    \n      @name grayscale\n      @methodOf Color#\n    \n      @returns {Color} A copy of the calling color converted to grayscale.\n      ###\n      grayscale: ->\n        @copy().grayscale$()\n    \n      ###*\n      The calling color converted to grayscale.\n    \n          color = Color(255, 255, 0)\n      \n          # modifies color into gray\n          color.grayscale$()\n      \n          color.toString()\n          # => 'rgba(128, 128, 128, 1)'\n    \n      @name grayscale$\n      @methodOf Color#\n    \n      @returns {Color} The calling color converted to grayscale.\n      ###\n      grayscale$: ->\n        hsl = @toHsl()\n    \n        g = round(hsl[2] * 255)\n    \n        @r = @g = @b = g\n    \n        return this \n    \n      ###*\n      A getter / setter for the hue value of the color. Passing no argument returns the \n      current hue value. Passing a value will set the hue to that value and return the color.\n      \n          magenta = Color(255, 0, 255)\n      \n          magenta.hue()\n          # => 300\n      \n          # modifies the color to be yellow\n          magenta.hue(60)\n      \n          # to see what it looks like\n          canvas.drawRect\n            color: magenta\n            x: 50 \n            y: 30 \n            width: 80\n            height: 80 \n    \n      @name hue\n      @methodOf Color#\n      @param {Number} [newVal] the new hue value\n    \n      @returns {Color|Number} returns the color object if you pass a new hue value and returns the hue otherwise \n      ###\n      hue: (newVal) ->\n        hsl = @toHsl()\n        if newVal?\n          hsl[0] = newVal\n    \n          [@r, @g, @b, @a] = hslToRgb(hsl)\n    \n          return this\n        else\n          return hsl[0]\n    \n      ###*\n      A getter / setter for the lightness value of the color. Passing no argument returns the \n      current lightness value. Passing a value will set the lightness to that value and return the color.\n    \n          magenta = Color(255, 0, 255)\n      \n          magenta.lightness()\n          # => 0.9\n      \n          # modifies magenta in place to be lighter\n          magenta.lightness(0.75)\n      \n          # to see what it looks like\n          canvas.drawRect\n            color: magenta\n            x: 50 \n            y: 30 \n            width: 80\n            height: 80 \n    \n      @name lightness\n      @methodOf Color#\n      @param {Number} [newVal] the new lightness value\n    \n      @returns {Color|Number} returns the color object if you pass a new lightness value and returns the lightness otherwise \n      ###\n      lightness: (newVal) ->\n        hsl = @toHsl()\n        if newVal?\n          hsl[2] = newVal\n    \n          [@r, @g, @b, @a] = hslToRgb(hsl)\n    \n          return this\n        else\n          return hsl[2]\n    \n      value: (newVal) ->\n        hsv = @toHsv()\n    \n        if newVal?\n          hsv[2] = newVal\n    \n          [@r, @g, @b, @a] = hsvToRgb(hsv)\n    \n          return this\n        else\n          return hsv[2]\n    \n      ###*\n      A copy of the calling color with its hue shifted by `degrees`. This differs from the hue setter in that it adds to the existing hue value and will wrap around 0 and 360.\n    \n          magenta = Color(255, 0, 255)\n      \n          magenta.hue()\n          # => 300\n      \n          yellow = magenta.shiftHue(120)\n      \n          # since magenta's hue is 300 we have wrapped\n          # around 360 to end up at 60\n          yellow.hue()\n          # => 60\n      \n          # to see what they look like\n          for color, index in [magenta, yellow]\n            canvas.drawRect\n              color: color\n              x: 20 + (60 * index)\n              y: 20 + (60 * index)\n              width: 60\n              height: 60 \n    \n      @name shiftHue\n      @methodOf Color#\n      @param {Number} degrees number of degrees to shift the hue on the color wheel.\n    \n      @returns {Color} A copy of the color with its hue shifted by `degrees`\n      ###\n      shiftHue: (degrees) ->\n        @copy().shiftHue$(degrees)\n    \n      ###*\n      The calling color with its hue shifted by `degrees`. This differs from the hue setter in that it adds to the existing hue value and will wrap around 0 and 360.\n    \n          magenta = Color(255, 0, 255)\n      \n          magenta.hue()\n          # => 300\n      \n          magenta.shiftHue$(120)\n      \n          # since magenta's hue is 300 we have wrapped\n          # around 360 to end up at 60. Also we have \n          # modified magenta in place to become yellow\n          magenta.hue()\n          # => 60\n      \n          magenta.toString()\n          # => 'rgba(255, 255, 0, 1)'\n    \n      @name shiftHue$\n      @methodOf Color#\n      @param {Number} degrees number of degrees to shift the hue on the color wheel.\n    \n      @returns {Color} The color with its hue shifted by `degrees`\n      ###      \n      shiftHue$: (degrees) ->\n        hsl = @toHsl()\n    \n        hsl[0] = (hsl[0] + round(degrees.round())).mod 360\n    \n        [@r, @g, @b, @a] = hslToRgb(hsl)\n    \n        return this\n    \n      ###*\n      Returns a copy of the calling color lightened by `amount` (Lightness of the color ranges from 0 to 1).\n    \n          green = Color(0, 255, 0)\n      \n          lightGreen = green.lighten(0.3)\n      \n          # to see what they look like\n          for color, index in [green, lightGreen]\n            canvas.drawRect\n              color: color\n              x: 20 + (60 * index)\n              y: 20 + (60 * index)\n              width: 60\n              height: 60 \n    \n      @name lighten\n      @methodOf Color#\n      @param {Number} amount Amount to lighten color by (between 0 to 1)\n    \n      @returns {Color} A new color. The lightness value is increased by `amount` from the original.\n      ###\n      lighten: (amount) ->\n        @copy().lighten$(amount)\n    \n      ###*\n      The calling color lightened by `amount` (Lightness of the color ranges from 0 to 1).\n    \n          green = Color(0, 255, 0)\n      \n          green.lighten$(0.2)\n      \n          # we have modified green in place\n          # to become lightGreen\n          green.toString()\n          # => 'rgba(102, 255, 102, 1)'\n    \n      @name lighten$\n      @methodOf Color#\n      @param {Number} amount Amount to lighten color by (between 0 - 1)\n    \n      @returns {Color} The calling color with its lightness value increased by `amount`.\n      ###\n      lighten$: (amount) ->\n        hsl = @toHsl()\n        hsl[2] += amount\n    \n        [@r, @g, @b, @a] = hslToRgb(hsl)\n    \n        return this \n    \n      ###*\n      A copy of the calling color mixed with `other` using `amount` as the \n      mixing ratio. If amount is not passed, then the colors are mixed evenly.\n    \n          red = Color(255, 0, 0)\n          yellow = Color(255, 255, 0)\n      \n          # With no amount argument the colors are mixed evenly\n          orange = red.mixWith(yellow)\n      \n          # With an amount of 0.3 we are mixing the color 30% red and 70% yellow\n          somethingCloseToOrange = red.mixWith(yellow, 0.3)\n      \n          # to see what they look like\n          for color, index in [red, yellow, orange, somethingCloseToOrange]\n            canvas.drawRect\n              color: color\n              x: 20 + (60 * (index % 2))\n              y: 20 + (60 * (if index > 1 then 1 else 0))\n              width: 60\n              height: 60 \n    \n      @name mixWith\n      @methodOf Color#\n      @param {Color} other the other color to mix\n      @param {Number} [amount] the mixing ratio of the calling color to `other`\n    \n      @returns {Color} A new color that is a mix of the calling color and `other`\n      ###\n      mixWith: (other, amount) ->\n        @copy().mixWith$(other, amount) \n    \n      ###*\n      A copy of the calling color mixed with `other` using `amount` as the \n      mixing ratio. If amount is not passed, then the colors are mixed evenly.\n    \n          red = Color(255, 0, 0)\n          yellow = Color(255, 255, 0)\n          anotherRed = Color(255, 0, 0)\n      \n          # With no amount argument the colors are mixed evenly\n          red.mixWith$(yellow)\n      \n          # We have modified red in place to be orange \n          red.toString()\n          # => 'rgba(255, 128, 0, 1)'    \n      \n          # With an amount of 0.3 we are mixing the color 30% red and 70% yellow\n          anotherRed.mixWith$(yellow, 0.3)\n      \n          # We have modified `anotherRed` in place to be somethingCloseToOrange \n          anotherRed.toString()\n          # => rgba(255, 179, 0, 1)\n    \n      @name mixWith$\n      @methodOf Color#\n      @param {Color} other the other color to mix\n      @param {Number} [amount] the mixing ratio of the calling color to `other`\n    \n      @returns {Color} The modified calling color after mixing it with `other`\n      ###\n      mixWith$: (other, amount) ->\n        amount ||= 0.5\n    \n        [@r, @g, @b, @a] = [@r, @g, @b, @a].zip([other.r, other.g, other.b, other.a]).map (array) ->\n          (array[0] * amount) + (array[1] * (1 - amount))\n    \n        [@r, @g, @b] = [@r, @g, @b].map (color) ->\n          color.round()\n    \n        return this \n    \n      ###*\n      A copy of the calling color with its saturation increased by `amount`.\n    \n          color = Color(50, 50, 200)\n      \n          color.saturation()\n          # => 0.6\n      \n          saturatedColor = color.saturate(0.2)\n      \n          saturatedColor.saturation()\n          # => 0.8\n      \n          # to see what they look like\n          for color, index in [color, saturatedColor]\n            canvas.drawRect\n              color: color\n              x: 20 + (60 * index)\n              y: 20 + (60 * index)\n              width: 60\n              height: 60 \n    \n      @name saturate\n      @methodOf Color#\n      @param {Number} amount the amount to increase saturation by\n    \n      @returns {Color} A copy of the calling color with its saturation increased by `amount`\n      ###\n      saturate: (amount) ->\n        @copy().saturate$(amount) \n    \n      ###*\n      The calling color with its saturation increased by `amount`.\n    \n          color = Color(50, 50, 200)\n      \n          color.saturation()\n          # => 0.6\n      \n          color.saturate$(0.2)\n      \n          # We have modified color in place and increased its saturation to 0.8\n          color.saturation()\n          # => 0.8\n      \n          color.toString()\n          # => rgba(25, 25, 225, 1)\n    \n      @name saturate$\n      @methodOf Color#\n      @param {Number} amount the amount to increase saturation by\n    \n      @returns {Color} The calling color with its saturation increased by `amount`\n      ###\n      saturate$: (amount) ->\n        hsl = @toHsl()\n        hsl[1] += amount\n    \n        [@r, @g, @b, @a] = hslToRgb(hsl) \n    \n        return this    \n    \n      ###*\n      A getter / setter for the saturation value of the color. Passing no argument returns the \n      current saturation value. Passing a value will set the saturation to that value and return the color.\n    \n          yellow = Color('hsl(60, 0.5, 0.5)')\n      \n          yellow.saturation()\n          # => 0.5\n      \n          yellow.saturation(0.8)\n      \n          # to see what it looks like\n          canvas.drawRect\n            color: yellow\n            x: 50 \n            y: 30 \n            width: 80\n            height: 80     \n    \n      @name saturation\n      @methodOf Color#\n      @param {Number} [newVal] the new saturation value\n    \n      @returns {Color|Number} returns the color object if you pass a new saturation value and returns the saturation otherwise \n      ###\n      saturation: (newVal, mode) ->\n        if mode == 'hsv'\n          hsv = @toHsv()\n          if newVal?\n            hsv[1] = newVal\n    \n            [@r, @g, @b, @a] = hsvToRgb(hsv)\n    \n            return this\n          else\n            return hsv[1]\n    \n        else\n          hsl = @toHsl()\n          if newVal?\n            hsl[1] = newVal\n    \n            [@r, @g, @b, @a] = hslToRgb(hsl)\n    \n            return this\n          else\n            return hsl[1]\n    \n      ###*\n      returns the Hex representation of the color. Exclude the leading `#` by passing false. \n    \n          color = Color('hsl(60, 1, 0.5)')\n      \n          # passing nothing will leave the `#` intact\n          color.toHex()\n          # => '#ffff00'\n      \n          # passing false will remove the `#`\n          color.toHex(false)\n          # => 'ffff00'\n    \n      @name toHex\n      @methodOf Color#\n      @param {Boolean} [leadingHash] if passed as false excludes the leading `#` from the string\n    \n      @returns {String} returns the Hex representation of the color \n      ###\n      toHex: (leadingHash) ->\n        padString = (hexString) ->        \n          if hexString.length == 1 then pad = \"0\" else pad = \"\" \n    \n          return pad + hexString\n    \n        hexFromNumber = (number) ->\n          return padString(number.toString(16))\n    \n        if leadingHash == false\n          \"#{hexFromNumber(@r)}#{hexFromNumber(@g)}#{hexFromNumber(@b)}\"\n        else\n          \"##{hexFromNumber(@r)}#{hexFromNumber(@g)}#{hexFromNumber(@b)}\"  \n    \n      ###*\n      returns an array of the hue, saturation, lightness, and alpha values of the color. \n    \n          magenta = Color(255, 0, 255)\n      \n          magenta.toHsl()\n          # => [300, 1, 0.5, 1]\n    \n      @name toHsl\n      @methodOf Color#\n    \n      @returns {Array} An array of the hue, saturation, lightness, and alpha values of the color. \n      ###\n      toHsl: ->\n        [r, g, b] = (channel / 255 for channel in [@r, @g, @b])\n    \n        {min, max} = [r, g, b].extremes()\n    \n        hue = saturation = lightness = (max + min) / 2\n        chroma = max - min\n    \n        if chroma.abs() < 0.00001\n          hue = saturation = 0\n        else\n          saturation =\n            if lightness > 0.5\n              chroma / (1 - lightness)\n            else \n              chroma / lightness\n    \n          saturation /= 2\n    \n          switch max\n            when r then hue = ((g - b) / chroma) + 0\n            when g then hue = ((b - r) / chroma) + 2\n            when b then hue = ((r - g) / chroma) + 4\n    \n          hue = (hue * 60).mod(360)\n    \n        return [hue, saturation, lightness, @a] \n    \n      toHsv: ->\n        r = @r / 255\n        g = @g / 255\n        b = @b / 255\n    \n        {min, max} = [r, g, b].extremes()\n    \n        h = s = v = max\n    \n        d = max - min\n        s = (if max == 0 then 0 else d / max)\n    \n        if max == min\n          h = 0\n        else\n          switch max\n            when r\n              h = (g - b) / d + (if g < b then 6 else 0)\n            when g\n              h = (b - r) / d + 2\n            when b\n              h = (r - g) / d + 4\n    \n          h *= 60\n    \n        return [h, s, v]\n    \n      ###*\n      returns string rgba representation of the color. \n    \n          red = Color('#ff0000')\n      \n          red.toString()\n          # => 'rgba(255, 0, 0, 1)'\n    \n      @name toString\n      @methodOf Color#\n    \n      @returns {String} The rgba string representation of the color \n      ###\n      toString: ->\n        \"rgba(#{@r}, #{@g}, #{@b}, #{@a})\"\n    \n      ###*\n      A copy of the calling color with its alpha reduced by `amount`.\n    \n          color = Color(0, 0, 0, 1)\n      \n          color.a\n          # => 1\n      \n          transparentColor = color.transparentize(0.5)\n      \n          transparentColor.a\n          # => 0.5\n      \n          # to see what they look like\n          for color, index in [color, transparentColor]\n            canvas.drawRect\n              color: color\n              x: 20 + (60 * index)\n              y: 20 + (60 * index)\n              width: 60\n              height: 60     \n    \n      @name transparentize\n      @methodOf Color#\n    \n      @returns {Color} A copy of the calling color with its alpha reduced by `amount`   \n      ###\n      transparentize: (amount) ->\n        @copy().transparentize$(amount) \n    \n      ###*\n      The calling color with its alpha reduced by `amount`.\n    \n          color = Color(0, 0, 0, 1)\n      \n          color.a\n          # => 1\n      \n          # We modify color in place\n          color.transparentize$(0.5)\n      \n          color.a\n          # => 0.5\n    \n      @name transparentize$\n      @methodOf Color#\n    \n      @returns {Color} The calling color with its alpha reduced by `amount`   \n      ###\n      transparentize$: (amount) ->\n        @a = (@a - amount).clamp(0, 1) \n    \n        return this  \n    \n      ###*\n      A copy of the calling color with its alpha increased by `amount`.\n    \n          color = Color(0, 0, 0, 0.25)\n      \n          color.a\n          # => 0.25\n      \n          opaqueColor = color.opacify(0.5)\n      \n          opaqueColor.a\n          # => 0.75\n      \n          # to see what they look like\n          for color, index in [color, opaqueColor]\n            canvas.drawRect\n              color: color\n              x: 20 + (60 * index)\n              y: 20 + (60 * index)\n              width: 60\n              height: 60     \n    \n      @name opacify\n      @methodOf Color#\n    \n      @returns {Color} A copy of the calling color with its alpha increased by `amount`   \n      ###\n      opacify: (amount) ->\n        @copy().opacify$(amount)   \n    \n      ###*\n      The calling color with its alpha increased by `amount`.\n    \n          color = Color(0, 0, 0, 0)\n      \n          color.a\n          # => 0\n      \n          # We modify color in place\n          color.opacify$(0.25)\n      \n          color.a\n          # => 0.25\n    \n      @name opacify$\n      @methodOf Color#\n    \n      @returns {Color} The calling color with its alpha increased by `amount`   \n      ###\n      opacify$: (amount) ->\n        @a = (@a + amount).clamp(0, 1) \n    \n        return this    \n    \n    ###*\n    returns a random color.\n    \n        Color.random().toString()\n        # => 'rgba(213, 144, 202, 1)'\n      \n        Color.random().toString()\n        # => 'rgba(1, 211, 24, 1)'\n    \n    @name random\n    @methodOf Color\n    \n    @returns {Color} A random color. \n    ###\n    Color.random = ->\n      Color(rand(256), rand(256), rand(256)) \n    \n    ###*\n    Mix two colors. Behaves just like `#mixWith` except that you are passing two colors.\n    \n        red = Color(255, 0, 0)\n        yellow = Color(255, 255, 0)\n      \n        # With no amount argument the colors are mixed evenly\n        orange = Color.mix(red, yellow)\n      \n        orange.toString()\n        # => 'rgba(255, 128, 0, 1)'    \n      \n        # With an amount of 0.3 we are mixing the color 30% red and 70% yellow\n        somethingCloseToOrange = Color.mix(red, yellow, 0.3)\n      \n        somethingCloseToOrange.toString()\n        # => rgba(255, 179, 0, 1)\n    \n    @name mix\n    @methodOf Color\n    @see Color#mixWith\n    @param {Color} color1 the first color to mix\n    @param {Color} color2 the second color to mix\n    @param {Number} amount the ratio to mix the colors \n    \n    @returns {Color} A new color that is the two colors mixed at the ratio defined by `amount` \n    ###\n    Color.mix = (color1, color2, amount) ->\n      amount ||= 0.5\n    \n      newColors = [color1.r, color1.g, color1.b, color1.a].zip([color2.r, color2.g, color2.b, color2.a]).map (array) ->\n        (array[0] * amount) + (array[1] * (1 - amount))\n    \n      return Color(newColors)     \n    \n    module.exports = Color\n",
      "type": "blob"
    },
    "test/color.coffee": {
      "path": "test/color.coffee",
      "mode": "100644",
      "content": "require \"../test_setup\"\n\nColor = require \"../main\"\n\nequalEnough = (actual, expected, tolerance=3, message) ->\n  message ||= \"\" + expected + \" within \" + tolerance + \" of \" + actual\n  ok(expected + tolerance >= actual && expected - tolerance <= actual, message)\n\ndescribe \"Color\", ->\n    \n  test \"r, g, b default to 0, a defaults to 1\", ->\n    color = Color()\n  \n    equal color.r, 0\n    equal color.g, 0\n    equal color.b, 0\n    equal color.a, 0\n  \n  test \"accepts a single array of length 3\", ->\n    color = Color([255, 1, 2])\n  \n    equalEnough color.r, 255\n    equalEnough color.g, 1\n    equalEnough color.b, 2\n  \n  test \"accepts a single array of length 4\", ->\n    color = Color([255, 4, 3, 0.8])\n  \n    equalEnough color.r, 255\n    equalEnough color.g, 4\n    equalEnough color.b, 3\n    equalEnough color.a, 0.8\n  \n  test \"accepts an array of length 3 as the first argument and an alpha value as the second\", ->\n    color = Color([100, 5, 3], 0.4)\n  \n    equalEnough color.r, 100\n    equalEnough color.g, 5\n    equalEnough color.b, 3\n    equalEnough color.a, 0.4\n  \n  test \"accepts an array of length 4 as the first argument and an alpha value. The alpha value passed as the second argument overrides the alpha in the array\", ->\n    color = Color([4, 20, 90, 0.1], 0.6)\n  \n    equalEnough color.r, 4\n    equalEnough color.g, 20\n    equalEnough color.b, 90\n    equalEnough color.a, 0.6\n  \n  test \"accepts an rgb string as the first argument and an alpha value as the second\", ->\n    color = Color('rgb(255, 40, 30)', 0.4)\n  \n    equalEnough color.r, 255\n    equalEnough color.g, 40\n    equalEnough color.b, 30\n    equalEnough color.a, 0.4\n  \n  test \"accepts an rgba string as the first argument and an alpha value as the second. The alpha value takes precedence over the alpha from the rgba string\", ->\n    color = Color('rgba(30, 20, 15, 0.8)', 0.35)\n  \n    equal color.r, 30\n    equal color.g, 20\n    equal color.b, 15\n    equal color.a, 0.35\n  \n  test \"parses rgba(0, 0, 0, 0) correctly\", ->\n    color = Color('rgba(0, 0, 0, 0)')\n  \n    equal color.r, 0\n    equal color.g, 0\n    equal color.b, 0\n    equal color.a, 0\n  \n  test \"parses rgb(0, 0, 0) correctly\", ->\n    color = Color('rgba(0, 0, 0)')\n  \n    equal color.r, 0\n    equal color.g, 0\n    equal color.b, 0\n    equal color.a, 1\n  \n  test \"parses hsla(60, 1, 0.5, 0) correctly\", ->\n    color = Color('hsla(60, 1, 0.5, 0)')\n  \n    equal color.r, 255 \n    equal color.g, 255\n    equal color.b, 0\n    equal color.a, 0\n  \n  test \"parses hsl(60, 1, 0.5) correctly\", ->\n    color = Color('hsl(60, 1, 0.5)')\n  \n    equal color.r, 255 \n    equal color.g, 255\n    equal color.b, 0\n    equal color.a, 1\n  \n  test \"accepts an hsl string as the first argument and an alpha value as the second\", ->\n    color = Color('hsl(63, 0.4, 0.3)', 0.21)\n  \n    equalEnough color.r, 104\n    equalEnough color.g, 107\n    equalEnough color.b, 46\n    equalEnough color.a, 0.21\n  \n  test \"accepts an hsla string as the first argument and an alpha value as the second. The alpha value takes precedence over the hsla string alpha value\", ->\n    color = Color('hsla(45, 0.3, 0.5, 0.1)', 0.47)\n  \n    equalEnough color.r, 166\n    equalEnough color.g, 147\n    equalEnough color.b, 89\n    equalEnough color.a, 0.47\n  \n  test \"should have peridot\", ->\n    color = Color('peridot')\n  \n    equals color.toHex(), '#87b84a'\n  \n  test \"accepts hex value of length 3 as first argument and alpha value as second argument\", ->\n    color = Color('#ff0', 0.5)\n  \n    equalEnough color.r, 255\n    equalEnough color.g, 255\n    equalEnough color.b, 0\n    equalEnough color.a, 0.5 \n  \n  test \"accepts hex value of length 4 as first argument and alpha value as second argument. The alpha value takes precedence over the alpha from the hex string.\", ->\n    color = Color('#ef3c', 0.3)\n  \n    equalEnough color.r, 238\n    equalEnough color.g, 255\n    equalEnough color.b, 51\n    equalEnough color.a, 0.3\n  \n  test \"accepts hex value of length 6 as first argument and alpha value as second argument\", ->\n    color = Color('#de34ab', 0.27)\n  \n    equalEnough color.r, 222\n    equalEnough color.g, 52\n    equalEnough color.b, 171\n    equalEnough color.a, 0.27 \n  \n  test \"accepts hex value of length 8 as first argument and alpha value as second argument. Alpha value takes precedence over hex alpha.\", ->\n    color = Color('#ab45cd', 0.59)\n  \n    equalEnough color.r, 171\n    equalEnough color.g, 69\n    equalEnough color.b, 205\n    equalEnough color.a, 0.59\n  \n  test \"accepts hex string of length 3\", ->\n    color = Color('#df2')\n  \n    equalEnough color.r, 221\n    equalEnough color.g, 255\n    equalEnough color.b, 34\n    equalEnough color.a, 1.0\n  \n  test \"accepts hex string of length 4\", ->\n    color = Color('#c987')\n  \n    equalEnough color.r, 204\n    equalEnough color.g, 153\n    equalEnough color.b, 136\n    equalEnough color.a.toFixed(2), 0.47\n  \n  test \"accepts hex string of length 6\", ->\n    color = Color('#cdef12')\n  \n    equalEnough color.r, 205\n    equalEnough color.g, 239\n    equalEnough color.b, 18\n    equalEnough color.a, 1.0\n  \n  test \"accepts hex string of length 8\", ->  \n    color = Color('#ef1234af')\n  \n    equalEnough color.r, 239\n    equalEnough color.g, 18\n    equalEnough color.b, 52\n    equalEnough color.a.toFixed(2), 0.69\n  \n  test \"accepts 3 numeric values\", ->\n    color = Color(34, 54, 39)\n  \n    equalEnough color.r, 34\n    equalEnough color.g, 54\n    equalEnough color.b, 39\n    equalEnough color.a, 1.0\n  \n  test \"accepts 4 numeric values\", ->\n    color = Color(23, 43, 100, 0.32)\n  \n    equalEnough color.r, 23\n    equalEnough color.g, 43\n    equalEnough color.b, 100\n    equalEnough color.a, 0.32\n  \n  test \"accepts a color object\", ->\n    color = Color(23, 54, 49, 1)\n  \n    newColor = Color(color)\n  \n    equal newColor.r, 23\n    equal newColor.g, 54\n    equal newColor.b, 49\n    equal newColor.a, 1\n  \n  test \"invalid color throws error\", ->\n    raises ->\n      Color(\"A Fake Color\")\n  \n  test \"#copy\", ->\n    color = Color(123, 231, 2)\n    copiedColor = color.copy()\n  \n    ok color.equal(copiedColor)\n    ok color != copiedColor\n  \n  test \"#equal\", ->\n    color1 = Color(255, 255, 255, 1)\n    color2 = Color([255, 255, 255])\n  \n    ok color1.equal(color2)\n  \n  test \"#toString\", ->\n    noAlpha = Color(30, 40, 23)\n    withAlpha = Color(29, 49, 50, 0.45)\n    decimalValues = Color(34.7, 52.2, 50.1, 0.45)\n  \n    equal noAlpha.toString(), \"rgba(30, 40, 23, 1)\"\n    equal withAlpha.toString(), \"rgba(29, 49, 50, 0.45)\"\n    equal decimalValues.toString(), \"rgba(35, 52, 50, 0.45)\"\n  \n  test \"#toHex\", ->\n    color = Color(23, 45, 100)\n  \n    equal color.toHex(), \"#172d64\"\n    equal color.toHex(false), \"172d64\" \n  \n  test \"#toHsl\", ->\n    color = Color(45, 29, 20)\n  \n    hsl = color.toHsl()\n  \n    equalEnough hsl[0].round(), 22\n    equalEnough hsl[1].toFixed(2), 0.38\n    equalEnough hsl[2].toFixed(2), 0.13\n    equalEnough hsl[3], 1.0\n  \n  test \"#hue\", ->\n    color = Color(20, 45, 49)\n    color.hue(60)\n  \n    equalEnough color.r, 51\n    equalEnough color.g, 51\n    equalEnough color.b, 21\n    equalEnough color.a, 1.0\n  \n  test \"#saturation\", ->\n    color = Color(40, 39, 29)\n    color.saturation(0.3)\n  \n    equalEnough color.r, 46\n    equalEnough color.g, 45\n    equalEnough color.b, 25\n    equalEnough color.a, 1.0  \n  \n  test \"#lightness\", ->\n    color = Color(4, 200, 49)\n    color.lightness(0.47)\n  \n    equalEnough color.r, 5\n    equalEnough color.g, 235\n    equalEnough color.b, 58\n    equalEnough color.a, 1.0 \n  \n  test \"#shiftHue\", ->\n    color = Color(34, 54, 239).shiftHue(20)\n  \n    equalEnough color.r, 84\n    equalEnough color.g, 37\n    equalEnough color.b, 239\n    equalEnough color.a, 1.0\n  \n  test \"#shiftHue$\", ->\n    color = Color(34, 54, 239)\n  \n    color.shiftHue$(60)\n  \n    equalEnough color.r, 218\n    equalEnough color.g, 37\n    equalEnough color.b, 239\n    equalEnough color.a, 1.0\n  \n  test \"#channels\", ->\n    no_alpha = Color(128, 2, 50)\n  \n    no_alpha_channels = no_alpha.channels()\n  \n    equal no_alpha_channels[0], 128\n    equal no_alpha_channels[1], 2\n    equal no_alpha_channels[2], 50\n    equal no_alpha_channels[3], 1\n  \n    alpha = Color(128, 2, 50, 0.3)\n  \n    alpha_channels = alpha.channels()\n  \n    equal alpha_channels[0], 128\n    equal alpha_channels[1], 2\n    equal alpha_channels[2], 50\n    equal alpha_channels[3], 0.3\n  \n  test \"#complement\", ->\n    color = Color(10, 30, 50).complement()\n  \n    equalEnough color.r, 51\n    equalEnough color.g, 31\n    equalEnough color.b, 10\n    equalEnough color.a, 1.0\n  \n  test \"#complement$\", ->\n    color = Color(10, 30, 50)\n  \n    color.complement$()\n  \n    equalEnough color.r, 51\n    equalEnough color.g, 31\n    equalEnough color.b, 10\n    equalEnough color.a, 1.0\n  \n  test \"#grayscale\", ->\n    color = Color(30, 40, 29).grayscale()\n  \n    equalEnough color.r, 35\n    equalEnough color.g, 35\n    equalEnough color.b, 35\n    equalEnough color.a, 1.0\n  \n  test \"#grayscale$\", ->\n    color = Color(30, 40, 29)\n  \n    color.grayscale$()\n  \n    equalEnough color.r, 35\n    equalEnough color.g, 35\n    equalEnough color.b, 35\n    equalEnough color.a, 1.0\n  \n  test \"#saturate\", ->\n    color = Color(100, 200, 150).saturate(0.3)\n  \n    equalEnough color.r, 69\n    equalEnough color.g, 232\n    equalEnough color.b, 150\n    equalEnough color.a, 1.0\n  \n  test \"#saturate$\", ->\n    color = Color(100, 200, 150)\n  \n    color.saturate$(0.3)\n  \n    equalEnough color.r, 69\n    equalEnough color.g, 232\n    equalEnough color.b, 150\n    equalEnough color.a, 1.0\n  \n  test \"#desaturate\", ->\n    color = Color(69, 232, 150).desaturate(0.3)\n  \n    equalEnough color.r, 100\n    equalEnough color.g, 200\n    equalEnough color.b, 150\n    equalEnough color.a, 1.0\n  \n  test \"#desaturate$\", ->\n    color = Color(69, 232, 150)\n  \n    color.desaturate$(0.3)\n  \n    equalEnough color.r, 100\n    equalEnough color.g, 200\n    equalEnough color.b, 150\n    equalEnough color.a, 1.0\n  \n  test \"#darken\", ->\n    color = Color(45, 64, 39).darken(0.1)\n  \n    equalEnough color.r, 22\n    equalEnough color.g, 32\n    equalEnough color.b, 19\n    equalEnough color.a, 1.0\n  \n  test \"#darken$\", ->\n    color = Color(45, 64, 39)\n  \n    color.darken$(0.1)\n  \n    equalEnough color.r, 22\n    equalEnough color.g, 32\n    equalEnough color.b, 19\n    equalEnough color.a, 1.0\n  \n  test \"#lighten\", ->\n    color = Color(22, 32, 19).lighten(0.1)\n  \n    equalEnough color.r, 45\n    equalEnough color.g, 64\n    equalEnough color.b, 39\n    equalEnough color.a, 1.0\n  \n  test \"#lighten$\", ->\n    color = Color(22, 32, 19)\n  \n    color.lighten$(0.1)\n  \n    equalEnough color.r, 45\n    equalEnough color.g, 64\n    equalEnough color.b, 39\n    equalEnough color.a, 1.0\n  \n  test \"#mixWith\", ->\n    color1 = Color(50, 40, 60, 0.3)\n    color2 = Color(10, 5, 16, 0.2)\n  \n    mixedColor = color1.mixWith(color2)\n  \n    equalEnough mixedColor.r, 30\n    equalEnough mixedColor.g, (45 / 2).round()\n    equalEnough mixedColor.b, (76 / 2).round()\n    equalEnough mixedColor.a, 0.5 / 2\n  \n    weightedMixedColor = color1.mixWith(color2, 0.1)\n  \n    equalEnough weightedMixedColor.r, ((50 * 0.1) + (10 * 0.9)).round()\n    equalEnough weightedMixedColor.g, ((40 * 0.1) + (5 * 0.9)).round()\n    equalEnough weightedMixedColor.b, ((60 * 0.1) + (16 * 0.9)).round()\n    equalEnough weightedMixedColor.a, (0.3 * 0.1) + (0.2 * 0.9) \n  \n  test \"#mixWith$\", ->\n    color1 = Color(50, 40, 60, 0.3)\n    color2 = Color(10, 5, 16, 0.2)\n  \n    color3 = Color(50, 40, 60, 0.3)\n  \n    color1.mixWith$(color2)\n  \n    equalEnough color1.r, 30\n    equalEnough color1.g, (45 / 2).round()\n    equalEnough color1.b, (76 / 2).round()\n    equalEnough color1.a, 0.5 / 2\n  \n    color3.mixWith$(color2, 0.1)\n  \n    equalEnough color3.r, ((50 * 0.1) + (10 * 0.9)).round()\n    equalEnough color3.g, ((40 * 0.1) + (5 * 0.9)).round()\n    equalEnough color3.b, ((60 * 0.1) + (16 * 0.9)).round()\n    equalEnough color3.a, (0.3 * 0.1) + (0.2 * 0.9) \n  \n  test \"Color.random\", ->\n    color = Color.random()\n  \n    ok 0 <= color.r <= 255\n    ok 0 <= color.g <= 255\n    ok 0 <= color.b <= 255\n    equalEnough color.a, 1.0\n  \n  test \"Color.mix\", ->\n    mixedColor = Color.mix(\n      Color(\"red\"),\n      Color(\"sky blue\")\n    )\n  \n    equalEnough mixedColor.r, 173\n    equalEnough mixedColor.g, 94\n    equalEnough mixedColor.b, 127\n    equalEnough mixedColor.a, 1\n  \n    weightedMixedColor = Color.mix(Color(0, 255, 0, 1), Color(255, 0, 255, 0.6), 0.1)\n  \n    equalEnough weightedMixedColor.r, ((0 * 0.1) + (255 * 0.9)).round()\n    equalEnough weightedMixedColor.g, ((255 * 0.1) + (0 * 0.9)).round()\n    equalEnough weightedMixedColor.b, ((0 * 0.1) + (255 * 0.9)).round()\n    equalEnough weightedMixedColor.a, (1 * 0.1) + (0.6 * 0.9)  \n  \n  test \"accepts named colors\", ->\n    white = Color(\"white\")\n  \n    equalEnough white.r, 255\n    equalEnough white.g, 255\n    equalEnough white.b, 255\n    equalEnough white.a, 1.0\n  \n    piPink = Color(\"Paul Irish Pink\")\n  \n    equalEnough piPink.r, 255\n    equalEnough piPink.g, 94\n    equalEnough piPink.b, 153\n    equalEnough piPink.a, 1.0\n  \n  test \"#transparentize\", ->\n    color = Color(0, 0, 0, 1)\n  \n    transparentColor = color.transparentize(0.5)\n  \n    equal color.a, 1\n    equal transparentColor.a, 0.5\n  \n  test \"#transparentize$\", ->\n    color = Color(0, 0, 0, 1)\n  \n    equal color.a, 1\n  \n    color.transparentize$(0.5)\n  \n    equal color.a, 0.5\n  \n  test \"#opacify\", ->\n    color = Color(0, 0, 0, 0)\n  \n    opaqueColor = color.opacify(0.5)\n  \n    equal color.a, 0\n    equal opaqueColor.a, 0.5\n  \n  test \"#opacify$\", ->\n    color = Color(0, 0, 0, 0)\n  \n    equal color.a, 0\n  \n    color.opacify$(0.5)\n  \n    equal color.a, 0.5\n",
      "type": "blob"
    },
    "test_setup.coffee.md": {
      "path": "test_setup.coffee.md",
      "mode": "100644",
      "content": "Test Setup\n==========\n\n    global.test = it\n    global.ok = assert\n    global.equal = assert.equal\n    global.equals = assert.equal\n    global.raises = assert.throws\n",
      "type": "blob"
    }
  },
  "distribution": {
    "main": {
      "path": "main",
      "content": "(function() {\n  var Color, channelize, hslParser, hslToRgb, hsvToRgb, parseHSL, parseHex, parseRGB, rgbParser, round,\n    __slice = [].slice;\n\n  rgbParser = /^rgba?\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3}),?\\s*(\\d?\\.?\\d*)?\\)$/;\n\n  hslParser = /^hsla?\\((\\d{1,3}),\\s*(\\d?\\.?\\d*),\\s*(\\d?\\.?\\d*),?\\s*(\\d?\\.?\\d*)?\\)$/;\n\n  round = Math.round;\n\n  parseHex = function(str) {\n    var alpha, hexString, i, rgb;\n    hexString = str.replace(/#/, '');\n    switch (hexString.length) {\n      case 3:\n      case 4:\n        if (hexString.length === 4) {\n          alpha = (parseInt(hexString.substr(3, 1), 16) * 0x11) / 255;\n        } else {\n          alpha = 1;\n        }\n        rgb = (function() {\n          var _i, _results;\n          _results = [];\n          for (i = _i = 0; _i <= 2; i = ++_i) {\n            _results.push(parseInt(hexString.substr(i, 1), 16) * 0x11);\n          }\n          return _results;\n        })();\n        rgb.push(alpha);\n        return rgb;\n      case 6:\n      case 8:\n        if (hexString.length === 8) {\n          alpha = parseInt(hexString.substr(6, 2), 16) / 255;\n        } else {\n          alpha = 1;\n        }\n        rgb = (function() {\n          var _i, _results;\n          _results = [];\n          for (i = _i = 0; _i <= 2; i = ++_i) {\n            _results.push(parseInt(hexString.substr(2 * i, 2), 16));\n          }\n          return _results;\n        })();\n        rgb.push(alpha);\n        return rgb;\n    }\n  };\n\n  parseRGB = function(colorString) {\n    var channel, channels, parsedColor;\n    if (!(channels = rgbParser.exec(colorString))) {\n      return void 0;\n    }\n    parsedColor = (function() {\n      var _i, _len, _ref, _results;\n      _ref = channels.slice(1, 5);\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        channel = _ref[_i];\n        _results.push(parseFloat(channel));\n      }\n      return _results;\n    })();\n    if (isNaN(parsedColor[3])) {\n      parsedColor[3] = 1;\n    }\n    return parsedColor;\n  };\n\n  parseHSL = function(colorString) {\n    var channel, channels, parsedColor;\n    if (!(channels = hslParser.exec(colorString))) {\n      return void 0;\n    }\n    parsedColor = (function() {\n      var _i, _len, _ref, _results;\n      _ref = channels.slice(1, 5);\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        channel = _ref[_i];\n        _results.push(parseFloat(channel));\n      }\n      return _results;\n    })();\n    if (isNaN(parsedColor[3])) {\n      parsedColor[3] = 1;\n    }\n    return hslToRgb(parsedColor);\n  };\n\n  hsvToRgb = function(hsv) {\n    var a, b, f, g, h, i, p, q, r, rgb, s, t, v;\n    r = g = b = null;\n    h = hsv[0], s = hsv[1], v = hsv[2], a = hsv[3];\n    if (a == null) {\n      a = 1;\n    }\n    i = (h / 60).floor();\n    f = h / 60 - i;\n    p = v * (1 - s);\n    q = v * (1 - f * s);\n    t = v * (1 - (1 - f) * s);\n    switch (i % 6) {\n      case 0:\n        r = v;\n        g = t;\n        b = p;\n        break;\n      case 1:\n        r = q;\n        g = v;\n        b = p;\n        break;\n      case 2:\n        r = p;\n        g = v;\n        b = t;\n        break;\n      case 3:\n        r = p;\n        g = q;\n        b = v;\n        break;\n      case 4:\n        r = t;\n        g = p;\n        b = v;\n        break;\n      case 5:\n        r = v;\n        g = p;\n        b = q;\n    }\n    rgb = [round(r * 255), round(g * 255), round(b * 255)];\n    return rgb.concat(a);\n  };\n\n  hslToRgb = function(hsl) {\n    var a, b, channel, g, h, hueToRgb, l, p, q, r, rgbMap, s;\n    h = hsl[0], s = hsl[1], l = hsl[2], a = hsl[3];\n    h = h % 360;\n    if (a == null) {\n      a = 1;\n    }\n    r = g = b = null;\n    hueToRgb = function(p, q, hue) {\n      hue = hue.mod(360);\n      if (hue < 60) {\n        return p + (q - p) * (hue / 60);\n      }\n      if (hue < 180) {\n        return q;\n      }\n      if (hue < 240) {\n        return p + (q - p) * ((240 - hue) / 60);\n      }\n      return p;\n    };\n    if (s === 0) {\n      r = g = b = l;\n    } else {\n      q = (l < 0.5 ? l * (1 + s) : l + s - l * s);\n      p = 2 * l - q;\n      r = hueToRgb(p, q, h + 120);\n      g = hueToRgb(p, q, h);\n      b = hueToRgb(p, q, h - 120);\n    }\n    rgbMap = (function() {\n      var _i, _len, _ref, _results;\n      _ref = [r, g, b];\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        channel = _ref[_i];\n        _results.push(round(channel * 255));\n      }\n      return _results;\n    })();\n    return rgbMap.concat(a);\n  };\n\n  channelize = function(color, alpha) {\n    var channel, result;\n    if (color.channels != null) {\n      return color.channels();\n    }\n    if (Array.isArray(color)) {\n      if (alpha != null) {\n        alpha = parseFloat(alpha);\n      } else if (color[3] != null) {\n        alpha = parseFloat(color[3]);\n      } else {\n        alpha = 1;\n      }\n      result = ((function() {\n        var _i, _len, _ref, _results;\n        _ref = color.slice(0, 3);\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          channel = _ref[_i];\n          _results.push(parseFloat(channel));\n        }\n        return _results;\n      })()).concat(alpha);\n    } else {\n      result = (typeof Color.lookup === \"function\" ? Color.lookup(color) : void 0) || parseHex(color) || parseRGB(color) || parseHSL(color);\n      if (alpha != null) {\n        result[3] = parseFloat(alpha);\n      }\n    }\n    return result;\n  };\n\n  /**\n  Create a new color. The constructor is very flexible. It accepts individual r, g, b, a values,\n  arrays of r, g, b values, hex strings, rgb strings, hsl strings, other Color objects, \n  and even the named colors from the xkcd survey: http://blog.xkcd.com/2010/05/03/color-survey-results/. \n  If no arguments are given, defaults to transparent.\n  \n      individualRgb = Color(23, 56, 49, 0.4)\n    \n      arrayRgb = Color([59, 100, 230])\n    \n      hex = Color('#ff0000')\n    \n      rgb = Color('rgb(0, 255, 0)')\n    \n      hsl = Color('hsl(180, 1, 0.5)')\n    \n      anotherColor = Color('blue')\n    \n      Color(anotherColor)\n      # => a new color with the same r, g, b, and alpha values as `anotherColor`\n    \n      # You have access to all sorts of weird colors.\n      # We give you all the named colors the browser recognizes\n      # and the ones from this survey \n      # http://blog.xkcd.com/2010/05/03/color-survey-results/\n      namedBrown = Color('Fuzzy Wuzzy Brown')\n    \n      # Uutput color in Hex format \n      namedBrown.toHex()\n      # => '#c45655'\n    \n      # Default behavior\n      transparent = Color()\n    \n      transparent.toString()\n      # => 'rgba(0, 0, 0, 0)' \n    \n      # let's print out the colors on a canvas to see what they look like\n      canvas.font('14px Helvetica')\n      for color, index in ['individualRgb', 'arrayRgb', 'hex', 'rgb', 'hsl', 'anotherColor', 'namedBrown']\n        canvas.centerText\n          color: eval(color)\n          text: color\n          y: 20 * (index + 1)  \n  \n  @name Color\n  @param {Array|Number|String|Color} args... An Array, r, g, b values, \n  a sequence of numbers defining r, g, b values, a hex or hsl string, another Color object, or a named color\n  @constructor\n  */\n\n\n  Color = function() {\n    var args, first, last, parsedColor;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    parsedColor = (function() {\n      switch (args.length) {\n        case 0:\n          return [0, 0, 0, 0];\n        case 1:\n          first = args[0];\n          return channelize(first);\n        case 2:\n          first = args[0], last = args[1];\n          return channelize(first, last);\n        default:\n          return channelize(args);\n      }\n    })();\n    if (!parsedColor) {\n      throw \"\" + (args.join(',')) + \" is an unknown color\";\n    }\n    return {\n      __proto__: Color.prototype,\n      r: round(parsedColor[0]),\n      g: round(parsedColor[1]),\n      b: round(parsedColor[2]),\n      a: parsedColor[3]\n    };\n  };\n\n  Color.prototype = {\n    /**\n    Returns the rgba color channels in an array.\n    \n        transparent =  Color()\n    \n        transparent.channels()\n        # => [0, 0, 0, 0]\n    \n        red = Color(\"#FF0000\")\n    \n        red.channels()\n        # => [255, 0, 0, 1]\n    \n        rgb = Color(200, 34, 2)\n    \n        rgb.channels()\n        # => [200, 34, 2, 1]\n    \n    @name channels\n    @methodOf Color#\n    \n    @returns {Array} Array of r, g, b, and alpha values of the color\n    */\n\n    channels: function() {\n      return [this.r, this.g, this.b, this.a];\n    },\n    /**\n    A copy of the calling color that is its complementary color on the color wheel.\n    \n        red = Color(255, 0, 0)\n    \n        cyan = red.complement()\n    \n        # to see what they look like\n        for color, index in [red, cyan]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60         \n    \n    @name complement\n    @methodOf Color#\n    \n    @returns {Color} new color that is a copy of the calling color with its hue shifted by 180 degrees on the color wheel\n    */\n\n    complement: function() {\n      return this.copy().complement$();\n    },\n    /**\n    Modifies the calling color to make it the complement of its previous value.\n    \n        red = Color(255, 0, 0)\n    \n        # modifies red in place to make it into cyan\n        red.complement$()\n    \n        red.toString()\n        # => 'rgba(0, 255, 255, 1)'\n    \n    @name complement$\n    @methodOf Color#\n    \n    @returns {Color} the color hue shifted by 180 degrees on the color wheel. Modifies the existing color.\n    */\n\n    complement$: function() {\n      return this.shiftHue$(180);\n    },\n    /**\n    A copy of the calling color.\n    \n        color = Color(0, 100, 200)\n    \n        copy = color.copy()\n    \n        color == copy\n        # => false\n    \n        color.equal(copy)\n        # => true\n    \n    @name copy\n    @methodOf Color#\n    \n    @returns {Color} A new color. A copy of the calling color\n    */\n\n    copy: function() {\n      return Color(this.r, this.g, this.b, this.a);\n    },\n    /**\n    Returns a copy of the calling color darkened by `amount` (Lightness of the color ranges from 0 to 1).\n    \n        green = Color(0, 255, 0)\n    \n        darkGreen = green.darken(0.3)\n    \n        # to see what they look like\n        for color, index in [green, darkGreen]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60         \n    \n    @name darken\n    @methodOf Color#\n    @param {Number} amount Amount to darken color by (between 0 - 1)\n    \n    @returns {Color} A new color. The lightness value is reduced by `amount` from the original.\n    */\n\n    darken: function(amount) {\n      return this.copy().darken$(amount);\n    },\n    /**\n    Modifies the color so that it is darkened by `amount` (Lightness of the color ranges from 0 to 1).\n    \n        green = Color(0, 255, 0)\n    \n        # Modifies green to be darkGreen\n        green.darken$(0.3)\n    \n        green.toString()\n        # => 'rgba(0, 102, 0, 1)'\n    \n    @name darken$\n    @methodOf Color#\n    @param {Number} amount Amount to darken color by (between 0 - 1)\n    \n    @returns {Color} the color with the lightness value reduced by `amount`\n    */\n\n    darken$: function(amount) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[2] -= amount;\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },\n    /**\n    A copy of the calling color with its saturation reduced by `amount`.\n    \n        blue = Color(0, 0, 255)\n    \n        desaturatedBlue = blue.desaturate(0.4)\n    \n        # to see what they look like\n        for color, index in [blue, desaturatedBlue]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60  \n    \n    @name desaturate\n    @methodOf Color#\n    @param {Number} amount Amount to reduce color saturation by (between 0 and 1)\n    \n    @returns {Color} A copy of the color with the saturation value reduced by `amount`\n    */\n\n    desaturate: function(amount) {\n      return this.copy().desaturate$(amount);\n    },\n    /**\n    The modified color with its saturation reduced by `amount`.\n    \n        blue = Color(0, 0, 255)\n    \n        # modifies blue to be desaturatedBlue\n        blue.desaturate$(0.4)\n    \n        blue.toString()\n        # => 'rgba(38, 38, 217, 1)'\n    \n    @name desaturate$\n    @methodOf Color#\n    @param {Number} amount Amount to reduce color saturation by (between 0 and 1)\n    \n    @returns {Color} the color with the saturation value reduced by `amount`\n    */\n\n    desaturate$: function(amount) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[1] -= amount;\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },\n    /**\n    Determine whether two colors are equal. Compares their r, g, b, and alpha values.\n    \n        hex = Color('#ffff00')\n        rgb = Color(255, 255, 0)\n    \n        hex == rgb\n        # => false\n    \n        hex.equal(rgb)\n        # => true\n    \n    @name equal\n    @methodOf Color#\n    @param {Color} other the color to compare to the calling color\n    \n    @returns {Boolean} true if the r, g, b, a values of the colors agree, false otherwise\n    */\n\n    equal: function(other) {\n      return other.r === this.r && other.g === this.g && other.b === this.b && other.a === this.a;\n    },\n    /**\n    A copy of the calling color converted to grayscale.\n    \n        yellow = Color(255, 255, 0)\n    \n        gray = yellow.grayscale()\n    \n        # to see what they look like\n        for color, index in [yellow, gray]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60 \n    \n    @name grayscale\n    @methodOf Color#\n    \n    @returns {Color} A copy of the calling color converted to grayscale.\n    */\n\n    grayscale: function() {\n      return this.copy().grayscale$();\n    },\n    /**\n    The calling color converted to grayscale.\n    \n        color = Color(255, 255, 0)\n    \n        # modifies color into gray\n        color.grayscale$()\n    \n        color.toString()\n        # => 'rgba(128, 128, 128, 1)'\n    \n    @name grayscale$\n    @methodOf Color#\n    \n    @returns {Color} The calling color converted to grayscale.\n    */\n\n    grayscale$: function() {\n      var g, hsl;\n      hsl = this.toHsl();\n      g = round(hsl[2] * 255);\n      this.r = this.g = this.b = g;\n      return this;\n    },\n    /**\n    A getter / setter for the hue value of the color. Passing no argument returns the \n    current hue value. Passing a value will set the hue to that value and return the color.\n    \n        magenta = Color(255, 0, 255)\n    \n        magenta.hue()\n        # => 300\n    \n        # modifies the color to be yellow\n        magenta.hue(60)\n    \n        # to see what it looks like\n        canvas.drawRect\n          color: magenta\n          x: 50 \n          y: 30 \n          width: 80\n          height: 80 \n    \n    @name hue\n    @methodOf Color#\n    @param {Number} [newVal] the new hue value\n    \n    @returns {Color|Number} returns the color object if you pass a new hue value and returns the hue otherwise\n    */\n\n    hue: function(newVal) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      if (newVal != null) {\n        hsl[0] = newVal;\n        _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n        return this;\n      } else {\n        return hsl[0];\n      }\n    },\n    /**\n    A getter / setter for the lightness value of the color. Passing no argument returns the \n    current lightness value. Passing a value will set the lightness to that value and return the color.\n    \n        magenta = Color(255, 0, 255)\n    \n        magenta.lightness()\n        # => 0.9\n    \n        # modifies magenta in place to be lighter\n        magenta.lightness(0.75)\n    \n        # to see what it looks like\n        canvas.drawRect\n          color: magenta\n          x: 50 \n          y: 30 \n          width: 80\n          height: 80 \n    \n    @name lightness\n    @methodOf Color#\n    @param {Number} [newVal] the new lightness value\n    \n    @returns {Color|Number} returns the color object if you pass a new lightness value and returns the lightness otherwise\n    */\n\n    lightness: function(newVal) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      if (newVal != null) {\n        hsl[2] = newVal;\n        _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n        return this;\n      } else {\n        return hsl[2];\n      }\n    },\n    value: function(newVal) {\n      var hsv, _ref;\n      hsv = this.toHsv();\n      if (newVal != null) {\n        hsv[2] = newVal;\n        _ref = hsvToRgb(hsv), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n        return this;\n      } else {\n        return hsv[2];\n      }\n    },\n    /**\n    A copy of the calling color with its hue shifted by `degrees`. This differs from the hue setter in that it adds to the existing hue value and will wrap around 0 and 360.\n    \n        magenta = Color(255, 0, 255)\n    \n        magenta.hue()\n        # => 300\n    \n        yellow = magenta.shiftHue(120)\n    \n        # since magenta's hue is 300 we have wrapped\n        # around 360 to end up at 60\n        yellow.hue()\n        # => 60\n    \n        # to see what they look like\n        for color, index in [magenta, yellow]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60 \n    \n    @name shiftHue\n    @methodOf Color#\n    @param {Number} degrees number of degrees to shift the hue on the color wheel.\n    \n    @returns {Color} A copy of the color with its hue shifted by `degrees`\n    */\n\n    shiftHue: function(degrees) {\n      return this.copy().shiftHue$(degrees);\n    },\n    /**\n    The calling color with its hue shifted by `degrees`. This differs from the hue setter in that it adds to the existing hue value and will wrap around 0 and 360.\n    \n        magenta = Color(255, 0, 255)\n    \n        magenta.hue()\n        # => 300\n    \n        magenta.shiftHue$(120)\n    \n        # since magenta's hue is 300 we have wrapped\n        # around 360 to end up at 60. Also we have \n        # modified magenta in place to become yellow\n        magenta.hue()\n        # => 60\n    \n        magenta.toString()\n        # => 'rgba(255, 255, 0, 1)'\n    \n    @name shiftHue$\n    @methodOf Color#\n    @param {Number} degrees number of degrees to shift the hue on the color wheel.\n    \n    @returns {Color} The color with its hue shifted by `degrees`\n    */\n\n    shiftHue$: function(degrees) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[0] = (hsl[0] + round(degrees.round())).mod(360);\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },\n    /**\n    Returns a copy of the calling color lightened by `amount` (Lightness of the color ranges from 0 to 1).\n    \n        green = Color(0, 255, 0)\n    \n        lightGreen = green.lighten(0.3)\n    \n        # to see what they look like\n        for color, index in [green, lightGreen]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60 \n    \n    @name lighten\n    @methodOf Color#\n    @param {Number} amount Amount to lighten color by (between 0 to 1)\n    \n    @returns {Color} A new color. The lightness value is increased by `amount` from the original.\n    */\n\n    lighten: function(amount) {\n      return this.copy().lighten$(amount);\n    },\n    /**\n    The calling color lightened by `amount` (Lightness of the color ranges from 0 to 1).\n    \n        green = Color(0, 255, 0)\n    \n        green.lighten$(0.2)\n    \n        # we have modified green in place\n        # to become lightGreen\n        green.toString()\n        # => 'rgba(102, 255, 102, 1)'\n    \n    @name lighten$\n    @methodOf Color#\n    @param {Number} amount Amount to lighten color by (between 0 - 1)\n    \n    @returns {Color} The calling color with its lightness value increased by `amount`.\n    */\n\n    lighten$: function(amount) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[2] += amount;\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },\n    /**\n    A copy of the calling color mixed with `other` using `amount` as the \n    mixing ratio. If amount is not passed, then the colors are mixed evenly.\n    \n        red = Color(255, 0, 0)\n        yellow = Color(255, 255, 0)\n    \n        # With no amount argument the colors are mixed evenly\n        orange = red.mixWith(yellow)\n    \n        # With an amount of 0.3 we are mixing the color 30% red and 70% yellow\n        somethingCloseToOrange = red.mixWith(yellow, 0.3)\n    \n        # to see what they look like\n        for color, index in [red, yellow, orange, somethingCloseToOrange]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * (index % 2))\n            y: 20 + (60 * (if index > 1 then 1 else 0))\n            width: 60\n            height: 60 \n    \n    @name mixWith\n    @methodOf Color#\n    @param {Color} other the other color to mix\n    @param {Number} [amount] the mixing ratio of the calling color to `other`\n    \n    @returns {Color} A new color that is a mix of the calling color and `other`\n    */\n\n    mixWith: function(other, amount) {\n      return this.copy().mixWith$(other, amount);\n    },\n    /**\n    A copy of the calling color mixed with `other` using `amount` as the \n    mixing ratio. If amount is not passed, then the colors are mixed evenly.\n    \n        red = Color(255, 0, 0)\n        yellow = Color(255, 255, 0)\n        anotherRed = Color(255, 0, 0)\n    \n        # With no amount argument the colors are mixed evenly\n        red.mixWith$(yellow)\n    \n        # We have modified red in place to be orange \n        red.toString()\n        # => 'rgba(255, 128, 0, 1)'    \n    \n        # With an amount of 0.3 we are mixing the color 30% red and 70% yellow\n        anotherRed.mixWith$(yellow, 0.3)\n    \n        # We have modified `anotherRed` in place to be somethingCloseToOrange \n        anotherRed.toString()\n        # => rgba(255, 179, 0, 1)\n    \n    @name mixWith$\n    @methodOf Color#\n    @param {Color} other the other color to mix\n    @param {Number} [amount] the mixing ratio of the calling color to `other`\n    \n    @returns {Color} The modified calling color after mixing it with `other`\n    */\n\n    mixWith$: function(other, amount) {\n      var _ref, _ref1;\n      amount || (amount = 0.5);\n      _ref = [this.r, this.g, this.b, this.a].zip([other.r, other.g, other.b, other.a]).map(function(array) {\n        return (array[0] * amount) + (array[1] * (1 - amount));\n      }), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      _ref1 = [this.r, this.g, this.b].map(function(color) {\n        return color.round();\n      }), this.r = _ref1[0], this.g = _ref1[1], this.b = _ref1[2];\n      return this;\n    },\n    /**\n    A copy of the calling color with its saturation increased by `amount`.\n    \n        color = Color(50, 50, 200)\n    \n        color.saturation()\n        # => 0.6\n    \n        saturatedColor = color.saturate(0.2)\n    \n        saturatedColor.saturation()\n        # => 0.8\n    \n        # to see what they look like\n        for color, index in [color, saturatedColor]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60 \n    \n    @name saturate\n    @methodOf Color#\n    @param {Number} amount the amount to increase saturation by\n    \n    @returns {Color} A copy of the calling color with its saturation increased by `amount`\n    */\n\n    saturate: function(amount) {\n      return this.copy().saturate$(amount);\n    },\n    /**\n    The calling color with its saturation increased by `amount`.\n    \n        color = Color(50, 50, 200)\n    \n        color.saturation()\n        # => 0.6\n    \n        color.saturate$(0.2)\n    \n        # We have modified color in place and increased its saturation to 0.8\n        color.saturation()\n        # => 0.8\n    \n        color.toString()\n        # => rgba(25, 25, 225, 1)\n    \n    @name saturate$\n    @methodOf Color#\n    @param {Number} amount the amount to increase saturation by\n    \n    @returns {Color} The calling color with its saturation increased by `amount`\n    */\n\n    saturate$: function(amount) {\n      var hsl, _ref;\n      hsl = this.toHsl();\n      hsl[1] += amount;\n      _ref = hslToRgb(hsl), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n      return this;\n    },\n    /**\n    A getter / setter for the saturation value of the color. Passing no argument returns the \n    current saturation value. Passing a value will set the saturation to that value and return the color.\n    \n        yellow = Color('hsl(60, 0.5, 0.5)')\n    \n        yellow.saturation()\n        # => 0.5\n    \n        yellow.saturation(0.8)\n    \n        # to see what it looks like\n        canvas.drawRect\n          color: yellow\n          x: 50 \n          y: 30 \n          width: 80\n          height: 80     \n    \n    @name saturation\n    @methodOf Color#\n    @param {Number} [newVal] the new saturation value\n    \n    @returns {Color|Number} returns the color object if you pass a new saturation value and returns the saturation otherwise\n    */\n\n    saturation: function(newVal, mode) {\n      var hsl, hsv, _ref, _ref1;\n      if (mode === 'hsv') {\n        hsv = this.toHsv();\n        if (newVal != null) {\n          hsv[1] = newVal;\n          _ref = hsvToRgb(hsv), this.r = _ref[0], this.g = _ref[1], this.b = _ref[2], this.a = _ref[3];\n          return this;\n        } else {\n          return hsv[1];\n        }\n      } else {\n        hsl = this.toHsl();\n        if (newVal != null) {\n          hsl[1] = newVal;\n          _ref1 = hslToRgb(hsl), this.r = _ref1[0], this.g = _ref1[1], this.b = _ref1[2], this.a = _ref1[3];\n          return this;\n        } else {\n          return hsl[1];\n        }\n      }\n    },\n    /**\n    returns the Hex representation of the color. Exclude the leading `#` by passing false. \n    \n        color = Color('hsl(60, 1, 0.5)')\n    \n        # passing nothing will leave the `#` intact\n        color.toHex()\n        # => '#ffff00'\n    \n        # passing false will remove the `#`\n        color.toHex(false)\n        # => 'ffff00'\n    \n    @name toHex\n    @methodOf Color#\n    @param {Boolean} [leadingHash] if passed as false excludes the leading `#` from the string\n    \n    @returns {String} returns the Hex representation of the color\n    */\n\n    toHex: function(leadingHash) {\n      var hexFromNumber, padString;\n      padString = function(hexString) {\n        var pad;\n        if (hexString.length === 1) {\n          pad = \"0\";\n        } else {\n          pad = \"\";\n        }\n        return pad + hexString;\n      };\n      hexFromNumber = function(number) {\n        return padString(number.toString(16));\n      };\n      if (leadingHash === false) {\n        return \"\" + (hexFromNumber(this.r)) + (hexFromNumber(this.g)) + (hexFromNumber(this.b));\n      } else {\n        return \"#\" + (hexFromNumber(this.r)) + (hexFromNumber(this.g)) + (hexFromNumber(this.b));\n      }\n    },\n    /**\n    returns an array of the hue, saturation, lightness, and alpha values of the color. \n    \n        magenta = Color(255, 0, 255)\n    \n        magenta.toHsl()\n        # => [300, 1, 0.5, 1]\n    \n    @name toHsl\n    @methodOf Color#\n    \n    @returns {Array} An array of the hue, saturation, lightness, and alpha values of the color.\n    */\n\n    toHsl: function() {\n      var b, channel, chroma, g, hue, lightness, max, min, r, saturation, _ref, _ref1;\n      _ref = (function() {\n        var _i, _len, _ref, _results;\n        _ref = [this.r, this.g, this.b];\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          channel = _ref[_i];\n          _results.push(channel / 255);\n        }\n        return _results;\n      }).call(this), r = _ref[0], g = _ref[1], b = _ref[2];\n      _ref1 = [r, g, b].extremes(), min = _ref1.min, max = _ref1.max;\n      hue = saturation = lightness = (max + min) / 2;\n      chroma = max - min;\n      if (chroma.abs() < 0.00001) {\n        hue = saturation = 0;\n      } else {\n        saturation = lightness > 0.5 ? chroma / (1 - lightness) : chroma / lightness;\n        saturation /= 2;\n        switch (max) {\n          case r:\n            hue = ((g - b) / chroma) + 0;\n            break;\n          case g:\n            hue = ((b - r) / chroma) + 2;\n            break;\n          case b:\n            hue = ((r - g) / chroma) + 4;\n        }\n        hue = (hue * 60).mod(360);\n      }\n      return [hue, saturation, lightness, this.a];\n    },\n    toHsv: function() {\n      var b, d, g, h, max, min, r, s, v, _ref;\n      r = this.r / 255;\n      g = this.g / 255;\n      b = this.b / 255;\n      _ref = [r, g, b].extremes(), min = _ref.min, max = _ref.max;\n      h = s = v = max;\n      d = max - min;\n      s = (max === 0 ? 0 : d / max);\n      if (max === min) {\n        h = 0;\n      } else {\n        switch (max) {\n          case r:\n            h = (g - b) / d + (g < b ? 6 : 0);\n            break;\n          case g:\n            h = (b - r) / d + 2;\n            break;\n          case b:\n            h = (r - g) / d + 4;\n        }\n        h *= 60;\n      }\n      return [h, s, v];\n    },\n    /**\n    returns string rgba representation of the color. \n    \n        red = Color('#ff0000')\n    \n        red.toString()\n        # => 'rgba(255, 0, 0, 1)'\n    \n    @name toString\n    @methodOf Color#\n    \n    @returns {String} The rgba string representation of the color\n    */\n\n    toString: function() {\n      return \"rgba(\" + this.r + \", \" + this.g + \", \" + this.b + \", \" + this.a + \")\";\n    },\n    /**\n    A copy of the calling color with its alpha reduced by `amount`.\n    \n        color = Color(0, 0, 0, 1)\n    \n        color.a\n        # => 1\n    \n        transparentColor = color.transparentize(0.5)\n    \n        transparentColor.a\n        # => 0.5\n    \n        # to see what they look like\n        for color, index in [color, transparentColor]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60     \n    \n    @name transparentize\n    @methodOf Color#\n    \n    @returns {Color} A copy of the calling color with its alpha reduced by `amount`\n    */\n\n    transparentize: function(amount) {\n      return this.copy().transparentize$(amount);\n    },\n    /**\n    The calling color with its alpha reduced by `amount`.\n    \n        color = Color(0, 0, 0, 1)\n    \n        color.a\n        # => 1\n    \n        # We modify color in place\n        color.transparentize$(0.5)\n    \n        color.a\n        # => 0.5\n    \n    @name transparentize$\n    @methodOf Color#\n    \n    @returns {Color} The calling color with its alpha reduced by `amount`\n    */\n\n    transparentize$: function(amount) {\n      this.a = (this.a - amount).clamp(0, 1);\n      return this;\n    },\n    /**\n    A copy of the calling color with its alpha increased by `amount`.\n    \n        color = Color(0, 0, 0, 0.25)\n    \n        color.a\n        # => 0.25\n    \n        opaqueColor = color.opacify(0.5)\n    \n        opaqueColor.a\n        # => 0.75\n    \n        # to see what they look like\n        for color, index in [color, opaqueColor]\n          canvas.drawRect\n            color: color\n            x: 20 + (60 * index)\n            y: 20 + (60 * index)\n            width: 60\n            height: 60     \n    \n    @name opacify\n    @methodOf Color#\n    \n    @returns {Color} A copy of the calling color with its alpha increased by `amount`\n    */\n\n    opacify: function(amount) {\n      return this.copy().opacify$(amount);\n    },\n    /**\n    The calling color with its alpha increased by `amount`.\n    \n        color = Color(0, 0, 0, 0)\n    \n        color.a\n        # => 0\n    \n        # We modify color in place\n        color.opacify$(0.25)\n    \n        color.a\n        # => 0.25\n    \n    @name opacify$\n    @methodOf Color#\n    \n    @returns {Color} The calling color with its alpha increased by `amount`\n    */\n\n    opacify$: function(amount) {\n      this.a = (this.a + amount).clamp(0, 1);\n      return this;\n    }\n  };\n\n  /**\n  returns a random color.\n  \n      Color.random().toString()\n      # => 'rgba(213, 144, 202, 1)'\n    \n      Color.random().toString()\n      # => 'rgba(1, 211, 24, 1)'\n  \n  @name random\n  @methodOf Color\n  \n  @returns {Color} A random color.\n  */\n\n\n  Color.random = function() {\n    return Color(rand(256), rand(256), rand(256));\n  };\n\n  /**\n  Mix two colors. Behaves just like `#mixWith` except that you are passing two colors.\n  \n      red = Color(255, 0, 0)\n      yellow = Color(255, 255, 0)\n    \n      # With no amount argument the colors are mixed evenly\n      orange = Color.mix(red, yellow)\n    \n      orange.toString()\n      # => 'rgba(255, 128, 0, 1)'    \n    \n      # With an amount of 0.3 we are mixing the color 30% red and 70% yellow\n      somethingCloseToOrange = Color.mix(red, yellow, 0.3)\n    \n      somethingCloseToOrange.toString()\n      # => rgba(255, 179, 0, 1)\n  \n  @name mix\n  @methodOf Color\n  @see Color#mixWith\n  @param {Color} color1 the first color to mix\n  @param {Color} color2 the second color to mix\n  @param {Number} amount the ratio to mix the colors \n  \n  @returns {Color} A new color that is the two colors mixed at the ratio defined by `amount`\n  */\n\n\n  Color.mix = function(color1, color2, amount) {\n    var newColors;\n    amount || (amount = 0.5);\n    newColors = [color1.r, color1.g, color1.b, color1.a].zip([color2.r, color2.g, color2.b, color2.a]).map(function(array) {\n      return (array[0] * amount) + (array[1] * (1 - amount));\n    });\n    return Color(newColors);\n  };\n\n  module.exports = Color;\n\n}).call(this);\n\n//# sourceURL=main.coffee",
      "type": "blob"
    },
    "test/color": {
      "path": "test/color",
      "content": "(function() {\n  var Color, equalEnough;\n\n  require(\"../test_setup\");\n\n  Color = require(\"../main\");\n\n  equalEnough = function(actual, expected, tolerance, message) {\n    if (tolerance == null) {\n      tolerance = 3;\n    }\n    message || (message = \"\" + expected + \" within \" + tolerance + \" of \" + actual);\n    return ok(expected + tolerance >= actual && expected - tolerance <= actual, message);\n  };\n\n  describe(\"Color\", function() {\n    test(\"r, g, b default to 0, a defaults to 1\", function() {\n      var color;\n      color = Color();\n      equal(color.r, 0);\n      equal(color.g, 0);\n      equal(color.b, 0);\n      return equal(color.a, 0);\n    });\n    test(\"accepts a single array of length 3\", function() {\n      var color;\n      color = Color([255, 1, 2]);\n      equalEnough(color.r, 255);\n      equalEnough(color.g, 1);\n      return equalEnough(color.b, 2);\n    });\n    test(\"accepts a single array of length 4\", function() {\n      var color;\n      color = Color([255, 4, 3, 0.8]);\n      equalEnough(color.r, 255);\n      equalEnough(color.g, 4);\n      equalEnough(color.b, 3);\n      return equalEnough(color.a, 0.8);\n    });\n    test(\"accepts an array of length 3 as the first argument and an alpha value as the second\", function() {\n      var color;\n      color = Color([100, 5, 3], 0.4);\n      equalEnough(color.r, 100);\n      equalEnough(color.g, 5);\n      equalEnough(color.b, 3);\n      return equalEnough(color.a, 0.4);\n    });\n    test(\"accepts an array of length 4 as the first argument and an alpha value. The alpha value passed as the second argument overrides the alpha in the array\", function() {\n      var color;\n      color = Color([4, 20, 90, 0.1], 0.6);\n      equalEnough(color.r, 4);\n      equalEnough(color.g, 20);\n      equalEnough(color.b, 90);\n      return equalEnough(color.a, 0.6);\n    });\n    test(\"accepts an rgb string as the first argument and an alpha value as the second\", function() {\n      var color;\n      color = Color('rgb(255, 40, 30)', 0.4);\n      equalEnough(color.r, 255);\n      equalEnough(color.g, 40);\n      equalEnough(color.b, 30);\n      return equalEnough(color.a, 0.4);\n    });\n    test(\"accepts an rgba string as the first argument and an alpha value as the second. The alpha value takes precedence over the alpha from the rgba string\", function() {\n      var color;\n      color = Color('rgba(30, 20, 15, 0.8)', 0.35);\n      equal(color.r, 30);\n      equal(color.g, 20);\n      equal(color.b, 15);\n      return equal(color.a, 0.35);\n    });\n    test(\"parses rgba(0, 0, 0, 0) correctly\", function() {\n      var color;\n      color = Color('rgba(0, 0, 0, 0)');\n      equal(color.r, 0);\n      equal(color.g, 0);\n      equal(color.b, 0);\n      return equal(color.a, 0);\n    });\n    test(\"parses rgb(0, 0, 0) correctly\", function() {\n      var color;\n      color = Color('rgba(0, 0, 0)');\n      equal(color.r, 0);\n      equal(color.g, 0);\n      equal(color.b, 0);\n      return equal(color.a, 1);\n    });\n    test(\"parses hsla(60, 1, 0.5, 0) correctly\", function() {\n      var color;\n      color = Color('hsla(60, 1, 0.5, 0)');\n      equal(color.r, 255);\n      equal(color.g, 255);\n      equal(color.b, 0);\n      return equal(color.a, 0);\n    });\n    test(\"parses hsl(60, 1, 0.5) correctly\", function() {\n      var color;\n      color = Color('hsl(60, 1, 0.5)');\n      equal(color.r, 255);\n      equal(color.g, 255);\n      equal(color.b, 0);\n      return equal(color.a, 1);\n    });\n    test(\"accepts an hsl string as the first argument and an alpha value as the second\", function() {\n      var color;\n      color = Color('hsl(63, 0.4, 0.3)', 0.21);\n      equalEnough(color.r, 104);\n      equalEnough(color.g, 107);\n      equalEnough(color.b, 46);\n      return equalEnough(color.a, 0.21);\n    });\n    test(\"accepts an hsla string as the first argument and an alpha value as the second. The alpha value takes precedence over the hsla string alpha value\", function() {\n      var color;\n      color = Color('hsla(45, 0.3, 0.5, 0.1)', 0.47);\n      equalEnough(color.r, 166);\n      equalEnough(color.g, 147);\n      equalEnough(color.b, 89);\n      return equalEnough(color.a, 0.47);\n    });\n    test(\"should have peridot\", function() {\n      var color;\n      color = Color('peridot');\n      return equals(color.toHex(), '#87b84a');\n    });\n    test(\"accepts hex value of length 3 as first argument and alpha value as second argument\", function() {\n      var color;\n      color = Color('#ff0', 0.5);\n      equalEnough(color.r, 255);\n      equalEnough(color.g, 255);\n      equalEnough(color.b, 0);\n      return equalEnough(color.a, 0.5);\n    });\n    test(\"accepts hex value of length 4 as first argument and alpha value as second argument. The alpha value takes precedence over the alpha from the hex string.\", function() {\n      var color;\n      color = Color('#ef3c', 0.3);\n      equalEnough(color.r, 238);\n      equalEnough(color.g, 255);\n      equalEnough(color.b, 51);\n      return equalEnough(color.a, 0.3);\n    });\n    test(\"accepts hex value of length 6 as first argument and alpha value as second argument\", function() {\n      var color;\n      color = Color('#de34ab', 0.27);\n      equalEnough(color.r, 222);\n      equalEnough(color.g, 52);\n      equalEnough(color.b, 171);\n      return equalEnough(color.a, 0.27);\n    });\n    test(\"accepts hex value of length 8 as first argument and alpha value as second argument. Alpha value takes precedence over hex alpha.\", function() {\n      var color;\n      color = Color('#ab45cd', 0.59);\n      equalEnough(color.r, 171);\n      equalEnough(color.g, 69);\n      equalEnough(color.b, 205);\n      return equalEnough(color.a, 0.59);\n    });\n    test(\"accepts hex string of length 3\", function() {\n      var color;\n      color = Color('#df2');\n      equalEnough(color.r, 221);\n      equalEnough(color.g, 255);\n      equalEnough(color.b, 34);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"accepts hex string of length 4\", function() {\n      var color;\n      color = Color('#c987');\n      equalEnough(color.r, 204);\n      equalEnough(color.g, 153);\n      equalEnough(color.b, 136);\n      return equalEnough(color.a.toFixed(2), 0.47);\n    });\n    test(\"accepts hex string of length 6\", function() {\n      var color;\n      color = Color('#cdef12');\n      equalEnough(color.r, 205);\n      equalEnough(color.g, 239);\n      equalEnough(color.b, 18);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"accepts hex string of length 8\", function() {\n      var color;\n      color = Color('#ef1234af');\n      equalEnough(color.r, 239);\n      equalEnough(color.g, 18);\n      equalEnough(color.b, 52);\n      return equalEnough(color.a.toFixed(2), 0.69);\n    });\n    test(\"accepts 3 numeric values\", function() {\n      var color;\n      color = Color(34, 54, 39);\n      equalEnough(color.r, 34);\n      equalEnough(color.g, 54);\n      equalEnough(color.b, 39);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"accepts 4 numeric values\", function() {\n      var color;\n      color = Color(23, 43, 100, 0.32);\n      equalEnough(color.r, 23);\n      equalEnough(color.g, 43);\n      equalEnough(color.b, 100);\n      return equalEnough(color.a, 0.32);\n    });\n    test(\"accepts a color object\", function() {\n      var color, newColor;\n      color = Color(23, 54, 49, 1);\n      newColor = Color(color);\n      equal(newColor.r, 23);\n      equal(newColor.g, 54);\n      equal(newColor.b, 49);\n      return equal(newColor.a, 1);\n    });\n    test(\"invalid color throws error\", function() {\n      return raises(function() {\n        return Color(\"A Fake Color\");\n      });\n    });\n    test(\"#copy\", function() {\n      var color, copiedColor;\n      color = Color(123, 231, 2);\n      copiedColor = color.copy();\n      ok(color.equal(copiedColor));\n      return ok(color !== copiedColor);\n    });\n    test(\"#equal\", function() {\n      var color1, color2;\n      color1 = Color(255, 255, 255, 1);\n      color2 = Color([255, 255, 255]);\n      return ok(color1.equal(color2));\n    });\n    test(\"#toString\", function() {\n      var decimalValues, noAlpha, withAlpha;\n      noAlpha = Color(30, 40, 23);\n      withAlpha = Color(29, 49, 50, 0.45);\n      decimalValues = Color(34.7, 52.2, 50.1, 0.45);\n      equal(noAlpha.toString(), \"rgba(30, 40, 23, 1)\");\n      equal(withAlpha.toString(), \"rgba(29, 49, 50, 0.45)\");\n      return equal(decimalValues.toString(), \"rgba(35, 52, 50, 0.45)\");\n    });\n    test(\"#toHex\", function() {\n      var color;\n      color = Color(23, 45, 100);\n      equal(color.toHex(), \"#172d64\");\n      return equal(color.toHex(false), \"172d64\");\n    });\n    test(\"#toHsl\", function() {\n      var color, hsl;\n      color = Color(45, 29, 20);\n      hsl = color.toHsl();\n      equalEnough(hsl[0].round(), 22);\n      equalEnough(hsl[1].toFixed(2), 0.38);\n      equalEnough(hsl[2].toFixed(2), 0.13);\n      return equalEnough(hsl[3], 1.0);\n    });\n    test(\"#hue\", function() {\n      var color;\n      color = Color(20, 45, 49);\n      color.hue(60);\n      equalEnough(color.r, 51);\n      equalEnough(color.g, 51);\n      equalEnough(color.b, 21);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#saturation\", function() {\n      var color;\n      color = Color(40, 39, 29);\n      color.saturation(0.3);\n      equalEnough(color.r, 46);\n      equalEnough(color.g, 45);\n      equalEnough(color.b, 25);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#lightness\", function() {\n      var color;\n      color = Color(4, 200, 49);\n      color.lightness(0.47);\n      equalEnough(color.r, 5);\n      equalEnough(color.g, 235);\n      equalEnough(color.b, 58);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#shiftHue\", function() {\n      var color;\n      color = Color(34, 54, 239).shiftHue(20);\n      equalEnough(color.r, 84);\n      equalEnough(color.g, 37);\n      equalEnough(color.b, 239);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#shiftHue$\", function() {\n      var color;\n      color = Color(34, 54, 239);\n      color.shiftHue$(60);\n      equalEnough(color.r, 218);\n      equalEnough(color.g, 37);\n      equalEnough(color.b, 239);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#channels\", function() {\n      var alpha, alpha_channels, no_alpha, no_alpha_channels;\n      no_alpha = Color(128, 2, 50);\n      no_alpha_channels = no_alpha.channels();\n      equal(no_alpha_channels[0], 128);\n      equal(no_alpha_channels[1], 2);\n      equal(no_alpha_channels[2], 50);\n      equal(no_alpha_channels[3], 1);\n      alpha = Color(128, 2, 50, 0.3);\n      alpha_channels = alpha.channels();\n      equal(alpha_channels[0], 128);\n      equal(alpha_channels[1], 2);\n      equal(alpha_channels[2], 50);\n      return equal(alpha_channels[3], 0.3);\n    });\n    test(\"#complement\", function() {\n      var color;\n      color = Color(10, 30, 50).complement();\n      equalEnough(color.r, 51);\n      equalEnough(color.g, 31);\n      equalEnough(color.b, 10);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#complement$\", function() {\n      var color;\n      color = Color(10, 30, 50);\n      color.complement$();\n      equalEnough(color.r, 51);\n      equalEnough(color.g, 31);\n      equalEnough(color.b, 10);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#grayscale\", function() {\n      var color;\n      color = Color(30, 40, 29).grayscale();\n      equalEnough(color.r, 35);\n      equalEnough(color.g, 35);\n      equalEnough(color.b, 35);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#grayscale$\", function() {\n      var color;\n      color = Color(30, 40, 29);\n      color.grayscale$();\n      equalEnough(color.r, 35);\n      equalEnough(color.g, 35);\n      equalEnough(color.b, 35);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#saturate\", function() {\n      var color;\n      color = Color(100, 200, 150).saturate(0.3);\n      equalEnough(color.r, 69);\n      equalEnough(color.g, 232);\n      equalEnough(color.b, 150);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#saturate$\", function() {\n      var color;\n      color = Color(100, 200, 150);\n      color.saturate$(0.3);\n      equalEnough(color.r, 69);\n      equalEnough(color.g, 232);\n      equalEnough(color.b, 150);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#desaturate\", function() {\n      var color;\n      color = Color(69, 232, 150).desaturate(0.3);\n      equalEnough(color.r, 100);\n      equalEnough(color.g, 200);\n      equalEnough(color.b, 150);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#desaturate$\", function() {\n      var color;\n      color = Color(69, 232, 150);\n      color.desaturate$(0.3);\n      equalEnough(color.r, 100);\n      equalEnough(color.g, 200);\n      equalEnough(color.b, 150);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#darken\", function() {\n      var color;\n      color = Color(45, 64, 39).darken(0.1);\n      equalEnough(color.r, 22);\n      equalEnough(color.g, 32);\n      equalEnough(color.b, 19);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#darken$\", function() {\n      var color;\n      color = Color(45, 64, 39);\n      color.darken$(0.1);\n      equalEnough(color.r, 22);\n      equalEnough(color.g, 32);\n      equalEnough(color.b, 19);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#lighten\", function() {\n      var color;\n      color = Color(22, 32, 19).lighten(0.1);\n      equalEnough(color.r, 45);\n      equalEnough(color.g, 64);\n      equalEnough(color.b, 39);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#lighten$\", function() {\n      var color;\n      color = Color(22, 32, 19);\n      color.lighten$(0.1);\n      equalEnough(color.r, 45);\n      equalEnough(color.g, 64);\n      equalEnough(color.b, 39);\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"#mixWith\", function() {\n      var color1, color2, mixedColor, weightedMixedColor;\n      color1 = Color(50, 40, 60, 0.3);\n      color2 = Color(10, 5, 16, 0.2);\n      mixedColor = color1.mixWith(color2);\n      equalEnough(mixedColor.r, 30);\n      equalEnough(mixedColor.g, (45 / 2).round());\n      equalEnough(mixedColor.b, (76 / 2).round());\n      equalEnough(mixedColor.a, 0.5 / 2);\n      weightedMixedColor = color1.mixWith(color2, 0.1);\n      equalEnough(weightedMixedColor.r, ((50 * 0.1) + (10 * 0.9)).round());\n      equalEnough(weightedMixedColor.g, ((40 * 0.1) + (5 * 0.9)).round());\n      equalEnough(weightedMixedColor.b, ((60 * 0.1) + (16 * 0.9)).round());\n      return equalEnough(weightedMixedColor.a, (0.3 * 0.1) + (0.2 * 0.9));\n    });\n    test(\"#mixWith$\", function() {\n      var color1, color2, color3;\n      color1 = Color(50, 40, 60, 0.3);\n      color2 = Color(10, 5, 16, 0.2);\n      color3 = Color(50, 40, 60, 0.3);\n      color1.mixWith$(color2);\n      equalEnough(color1.r, 30);\n      equalEnough(color1.g, (45 / 2).round());\n      equalEnough(color1.b, (76 / 2).round());\n      equalEnough(color1.a, 0.5 / 2);\n      color3.mixWith$(color2, 0.1);\n      equalEnough(color3.r, ((50 * 0.1) + (10 * 0.9)).round());\n      equalEnough(color3.g, ((40 * 0.1) + (5 * 0.9)).round());\n      equalEnough(color3.b, ((60 * 0.1) + (16 * 0.9)).round());\n      return equalEnough(color3.a, (0.3 * 0.1) + (0.2 * 0.9));\n    });\n    test(\"Color.random\", function() {\n      var color, _ref, _ref1, _ref2;\n      color = Color.random();\n      ok((0 <= (_ref = color.r) && _ref <= 255));\n      ok((0 <= (_ref1 = color.g) && _ref1 <= 255));\n      ok((0 <= (_ref2 = color.b) && _ref2 <= 255));\n      return equalEnough(color.a, 1.0);\n    });\n    test(\"Color.mix\", function() {\n      var mixedColor, weightedMixedColor;\n      mixedColor = Color.mix(Color(\"red\"), Color(\"sky blue\"));\n      equalEnough(mixedColor.r, 173);\n      equalEnough(mixedColor.g, 94);\n      equalEnough(mixedColor.b, 127);\n      equalEnough(mixedColor.a, 1);\n      weightedMixedColor = Color.mix(Color(0, 255, 0, 1), Color(255, 0, 255, 0.6), 0.1);\n      equalEnough(weightedMixedColor.r, ((0 * 0.1) + (255 * 0.9)).round());\n      equalEnough(weightedMixedColor.g, ((255 * 0.1) + (0 * 0.9)).round());\n      equalEnough(weightedMixedColor.b, ((0 * 0.1) + (255 * 0.9)).round());\n      return equalEnough(weightedMixedColor.a, (1 * 0.1) + (0.6 * 0.9));\n    });\n    test(\"accepts named colors\", function() {\n      var piPink, white;\n      white = Color(\"white\");\n      equalEnough(white.r, 255);\n      equalEnough(white.g, 255);\n      equalEnough(white.b, 255);\n      equalEnough(white.a, 1.0);\n      piPink = Color(\"Paul Irish Pink\");\n      equalEnough(piPink.r, 255);\n      equalEnough(piPink.g, 94);\n      equalEnough(piPink.b, 153);\n      return equalEnough(piPink.a, 1.0);\n    });\n    test(\"#transparentize\", function() {\n      var color, transparentColor;\n      color = Color(0, 0, 0, 1);\n      transparentColor = color.transparentize(0.5);\n      equal(color.a, 1);\n      return equal(transparentColor.a, 0.5);\n    });\n    test(\"#transparentize$\", function() {\n      var color;\n      color = Color(0, 0, 0, 1);\n      equal(color.a, 1);\n      color.transparentize$(0.5);\n      return equal(color.a, 0.5);\n    });\n    test(\"#opacify\", function() {\n      var color, opaqueColor;\n      color = Color(0, 0, 0, 0);\n      opaqueColor = color.opacify(0.5);\n      equal(color.a, 0);\n      return equal(opaqueColor.a, 0.5);\n    });\n    return test(\"#opacify$\", function() {\n      var color;\n      color = Color(0, 0, 0, 0);\n      equal(color.a, 0);\n      color.opacify$(0.5);\n      return equal(color.a, 0.5);\n    });\n  });\n\n}).call(this);\n\n//# sourceURL=test/color.coffee",
      "type": "blob"
    },
    "test_setup": {
      "path": "test_setup",
      "content": "(function() {\n  global.test = it;\n\n  global.ok = assert;\n\n  global.equal = assert.equal;\n\n  global.equals = assert.equal;\n\n  global.raises = assert.throws;\n\n}).call(this);\n\n//# sourceURL=test_setup.coffee",
      "type": "blob"
    }
  },
  "progenitor": {
    "url": "http://strd6.github.io/editor/"
  },
  "entryPoint": "main",
  "repository": {
    "id": 15485748,
    "name": "color",
    "full_name": "distri/color",
    "owner": {
      "login": "distri",
      "id": 6005125,
      "avatar_url": "https://identicons.github.com/f90c81ffc1498e260c820082f2e7ca5f.png",
      "gravatar_id": null,
      "url": "https://api.github.com/users/distri",
      "html_url": "https://github.com/distri",
      "followers_url": "https://api.github.com/users/distri/followers",
      "following_url": "https://api.github.com/users/distri/following{/other_user}",
      "gists_url": "https://api.github.com/users/distri/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/distri/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/distri/subscriptions",
      "organizations_url": "https://api.github.com/users/distri/orgs",
      "repos_url": "https://api.github.com/users/distri/repos",
      "events_url": "https://api.github.com/users/distri/events{/privacy}",
      "received_events_url": "https://api.github.com/users/distri/received_events",
      "type": "Organization",
      "site_admin": false
    },
    "private": false,
    "html_url": "https://github.com/distri/color",
    "description": "Taste the rainbow",
    "fork": false,
    "url": "https://api.github.com/repos/distri/color",
    "forks_url": "https://api.github.com/repos/distri/color/forks",
    "keys_url": "https://api.github.com/repos/distri/color/keys{/key_id}",
    "collaborators_url": "https://api.github.com/repos/distri/color/collaborators{/collaborator}",
    "teams_url": "https://api.github.com/repos/distri/color/teams",
    "hooks_url": "https://api.github.com/repos/distri/color/hooks",
    "issue_events_url": "https://api.github.com/repos/distri/color/issues/events{/number}",
    "events_url": "https://api.github.com/repos/distri/color/events",
    "assignees_url": "https://api.github.com/repos/distri/color/assignees{/user}",
    "branches_url": "https://api.github.com/repos/distri/color/branches{/branch}",
    "tags_url": "https://api.github.com/repos/distri/color/tags",
    "blobs_url": "https://api.github.com/repos/distri/color/git/blobs{/sha}",
    "git_tags_url": "https://api.github.com/repos/distri/color/git/tags{/sha}",
    "git_refs_url": "https://api.github.com/repos/distri/color/git/refs{/sha}",
    "trees_url": "https://api.github.com/repos/distri/color/git/trees{/sha}",
    "statuses_url": "https://api.github.com/repos/distri/color/statuses/{sha}",
    "languages_url": "https://api.github.com/repos/distri/color/languages",
    "stargazers_url": "https://api.github.com/repos/distri/color/stargazers",
    "contributors_url": "https://api.github.com/repos/distri/color/contributors",
    "subscribers_url": "https://api.github.com/repos/distri/color/subscribers",
    "subscription_url": "https://api.github.com/repos/distri/color/subscription",
    "commits_url": "https://api.github.com/repos/distri/color/commits{/sha}",
    "git_commits_url": "https://api.github.com/repos/distri/color/git/commits{/sha}",
    "comments_url": "https://api.github.com/repos/distri/color/comments{/number}",
    "issue_comment_url": "https://api.github.com/repos/distri/color/issues/comments/{number}",
    "contents_url": "https://api.github.com/repos/distri/color/contents/{+path}",
    "compare_url": "https://api.github.com/repos/distri/color/compare/{base}...{head}",
    "merges_url": "https://api.github.com/repos/distri/color/merges",
    "archive_url": "https://api.github.com/repos/distri/color/{archive_format}{/ref}",
    "downloads_url": "https://api.github.com/repos/distri/color/downloads",
    "issues_url": "https://api.github.com/repos/distri/color/issues{/number}",
    "pulls_url": "https://api.github.com/repos/distri/color/pulls{/number}",
    "milestones_url": "https://api.github.com/repos/distri/color/milestones{/number}",
    "notifications_url": "https://api.github.com/repos/distri/color/notifications{?since,all,participating}",
    "labels_url": "https://api.github.com/repos/distri/color/labels{/name}",
    "releases_url": "https://api.github.com/repos/distri/color/releases{/id}",
    "created_at": "2013-12-28T02:31:58Z",
    "updated_at": "2013-12-28T02:31:58Z",
    "pushed_at": "2013-12-28T02:31:58Z",
    "git_url": "git://github.com/distri/color.git",
    "ssh_url": "git@github.com:distri/color.git",
    "clone_url": "https://github.com/distri/color.git",
    "svn_url": "https://github.com/distri/color",
    "homepage": null,
    "size": 0,
    "stargazers_count": 0,
    "watchers_count": 0,
    "language": null,
    "has_issues": true,
    "has_downloads": true,
    "has_wiki": true,
    "forks_count": 0,
    "mirror_url": null,
    "open_issues_count": 0,
    "forks": 0,
    "open_issues": 0,
    "watchers": 0,
    "default_branch": "master",
    "master_branch": "master",
    "permissions": {
      "admin": true,
      "push": true,
      "pull": true
    },
    "organization": {
      "login": "distri",
      "id": 6005125,
      "avatar_url": "https://identicons.github.com/f90c81ffc1498e260c820082f2e7ca5f.png",
      "gravatar_id": null,
      "url": "https://api.github.com/users/distri",
      "html_url": "https://github.com/distri",
      "followers_url": "https://api.github.com/users/distri/followers",
      "following_url": "https://api.github.com/users/distri/following{/other_user}",
      "gists_url": "https://api.github.com/users/distri/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/distri/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/distri/subscriptions",
      "organizations_url": "https://api.github.com/users/distri/orgs",
      "repos_url": "https://api.github.com/users/distri/repos",
      "events_url": "https://api.github.com/users/distri/events{/privacy}",
      "received_events_url": "https://api.github.com/users/distri/received_events",
      "type": "Organization",
      "site_admin": false
    },
    "network_count": 0,
    "subscribers_count": 2,
    "branch": "master",
    "defaultBranch": "master"
  },
  "dependencies": {}
}
